*********************************************************************
*
* Zaxxon
* For the TI-99/4A home computer with F18A
*
* February 2021 -
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ  >9000                      ; Speech read
spchwt equ  >9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
nametb equ  >0000                      ; Name table base
namet0 equ  >0000                      ; Name table page 0
vdpvar equ  >03c0                      ; VDP variables
gpusta equ  >03c0                      ; GPU status
scrlps equ  >03c2                      ; Scroll position
collis equ  >03c4                      ; Collision results
tilatb equ  >0400                      ; Tile attribute table
spratb equ  >0500                      ; Sprite attribute table
sprat2 equ  >0580                      ; Sprite attribute table 2
sprbuf equ  >0600                      ; Sprite buffer (162 bytes for 16 sprites)
namet1 equ  >0800                      ; Name table page 1 (64 bytes free)
nam2tb equ  >0c00                      ; Name table 2 base (64 bytes free)
ptrntb equ  >1000                      ; Pattern table base
ptrnt0 equ  >1000                      ; Pattern table plane 0
ptrnt1 equ  >1800                      ; Pattern table plane 1
ptrnt2 equ  >2000                      ; Pattern table plane 2
gputmp equ  >2800                      ; GPU program temporary location
sprptb equ  >2800                      ; Sprite pattern table base
sprpt0 equ  >2800                      ; Sprite pattern table plane 0
sprpt1 equ  >3000                      ; Sprite pattern table plane 1
sprpt2 equ  >3800                      ; Sprite pattern table plane 2
gpuprg equ  >4000                      ; GPU program location

**
* Constants
*
backdrop_color:
       equ  0
screen_height:
       equ  240
screen_width:
       equ  256
screen_height_chars:
       equ  30
screen_width_chars:
       equ  32
window_width:
       equ  224
window_left:
       equ  16
window_top:
       equ  -36
map_width:
       equ  228
map_height:
       equ  26
map_size:
       equ  map_width*map_height
tl2_first_char:
       equ  249
tl2_chars:
       equ  7
max_sprites:
       equ  18
level_1_map:
       equ  >6000
map_bank_select:
       equ  >6008
sprite_bank_select:
       equ  >600a
sprite_create_x:
       equ  255
n_sprite_patterns:
       equ  64
max_uploaded_chars_per_frame:
       equ  4
isometric_x0:
       equ  16
isometric_y0:
       equ  80
isometric_z0:
       equ  16
isometric_center_y:
       equ  128
wall_1_x:
       equ  228
wall_2_x:
       equ  1764
wall_height:
       equ  56

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  wrksp+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
**
* PAD variables
*
padvar:
       equ  padcon+2                   ; Start of pad variables
vdp_status:
       equ  padvar
scroll_pos:
       equ  vdp_status+2
scroll_x:
       equ  scroll_pos+2
scroll_y:
       equ  scroll_x+2
char_diff_ptr:
       equ  scroll_y+2
chars_to_upload:
       equ  char_diff_ptr+2
sprite_def_ptr:
       equ  chars_to_upload+2
sprites_end_ptr:
       equ  sprite_def_ptr+2
player_sprite:
       equ  sprites_end_ptr+2
player_shadow:
       equ  player_sprite+2
player_fire:
       equ  player_shadow+2
player_status:
       equ  player_fire+2
pad_max:
       equ  player_status+2

***************************************************************
*
* Lower memory
*
       aorg >2000

***************************************************************
*
* Main program
*
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r15,vdpwd                  ; Constant for writing to VDP
       bl   @one_time_init
restart:
       bl   @init_level
loop:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @gpu_run
       bl   @upload_characters
       bl   @draw_column
       bl   @wait_gpu
       bl   @player_collisions
       bl   @bullet_collisions
       bl   @move_player
       bl   @fire
       bl   @move_sprites
       bl   @create_sprites
       bl   @upload_sprites
       mov  @player_status,r0
       jne  restart
       bl   @scroll
       c    @scroll_x,@scroll_max
       jl   loop
       jmp  restart

scroll_max:
       data map_width*8+window_width

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

*********************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Horizontal scroll offset
       mov  @scroll_x,r0
       andi r0,>00ff
       ori  r0,>1b00
       bl   @vwtr
*      Calculate vertical page and offset
       clr  r0
       mov  @scroll_y,r1
       li   r2,screen_height
       div  r2,r0                      ; r0 quotient=pages, r1 remainder=offset
*      Vertical page (name table)
       andi r0,1                       ; Bit 0 of quotient
       sla  r0,1                       ; Shift to select name table
       ori  r0,>0200                   ; Name table
       bl   @vwtr
*      Vertical scroll offset
       mov  r1,r0                      ; Offset
       ori  r0,>1c00
       bl   @vwtr
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Upload sprites
*
upload_sprites:
       .proc
       li   r0,sprbuf
       bl   @vwad
       li   r2,r1lb
       li   r4,sprites
upload_sprites_1:
       c    r4,@sprites_end_ptr
       jeq  upload_sprites_4
       mov  @sprite_type(r4),r6
       jeq  upload_sprites_3
       mov  @sprite_z(r4),r3
       jlt  upload_sprites_3           ; Skip if z < 0
       movb r4,*r15                    ; Sprite address
       movb @r4lb,*r15
       mov  @sprite_type_index(r6),r1  ; Type index
       movb r1,*r15
       movb *r2,*r15
       mov  @sprite_x(r4),r1
       movb r1,*r15
       movb *r2,*r15                   ; Low byte
       mov  @sprite_y(r4),r1
       movb r1,*r15
       movb *r2,*r15                   ; Low byte
       mov  r3,r1                      ; z
       movb r1,*r15
       movb *r2,*r15                   ; Low byte
upload_sprites_3:
       ai   r4,sprite_size
       jmp  upload_sprites_1
upload_sprites_4:
       clr  *r15
       clr  *r15
upload_sprites_5:
       .endproc
*// upload_sprites

*********************************************************************
*
* Upload characters
*
* diff_ptr points to the difference structure
*
upload_characters:
       .proc
       mov  @scroll_x,r0
       andi r0,7
       jne  upload_characters_0
*      Get new characters to upload
       mov  @char_diff_ptr,r5
       ci   r5,diff_end
       jhe  upload_characters_3
       clr  r6
       movb *r5+,r6
       jeq  upload_characters_3
       swpb r6
       mov  r6,@chars_to_upload
       mov  r5,@char_diff_ptr
*      Calculate how many characters to upload this frame
upload_characters_0:
       mov  @chars_to_upload,r6
       jeq  upload_characters_4                ; Skip if none left
       ci   r6,max_uploaded_chars_per_frame
       jle  upload_characters_1
       ci   r0,7                               ; At frame 7 we need to finish
       jeq  upload_characters_1
       li   r6,max_uploaded_chars_per_frame    ; Limit number of characters to upload
*      Upload characters
upload_characters_1:
       s    r6,@chars_to_upload
       mov  @char_diff_ptr,r5
upload_characters_2:
       clr  r0
       movb *r5+,r0
       swpb r0
       movb *r5+,r1
       swpb r1
       movb *r5+,r1
       swpb r1
       bl   @upload_character
       dec  r6
       jne  upload_characters_2
upload_characters_3:
       mov  r5,@char_diff_ptr
upload_characters_4:
       .endproc
*// upload_characters

*********************************************************************
*
* Upload character
*
* r0: VDP index
* r1: Global index
*
upload_character:
       .proc
       mov  r0,r3
       mov  r1,r4
*      Tile attribute
       ai   r0,tilatb
       movb @TAT0(r1),r1
       bl   @vsbw
*      Pattern
       mov  r3,r0
       mov  r4,r1
       sla  r0,3
       ai   r0,ptrntb
       sla  r1,3
       ai   r1,P0_0
       li   r2,3
upload_character_1:
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       ai   r0,ptrnt1-ptrnt0
       ai   r1,P1_0-P0_0-8
       dec  r2
       jne  upload_character_1
       .endproc
*// upload_character

*********************************************************************
*
* Draw column
*
draw_column:
       .proc
       mov  @scroll_x,r0
       andi r0,7
       jne  draw_column_3
*      Set VDP address increment
       li   r0,>3020                   ; Set VDP address increment
       bl   @vwtr                      ; to 32
*      Calculate VDP address
       mov  @scroll_x,r0
       ai   r0,window_width+window_left ; Right side of window
       srl  r0,3                       ; Offset in characters
       andi r0,screen_width_chars-1    ; VDP address
*      Vertical
       clr  r2                         ; For division
       mov  @scroll_y,r3               ; Scroll offset
       ai   r3,window_top              ; Draw start
       li   r4,screen_height           ; Divisor
       div  r4,r2                      ; r2 quotient=page, r3 remainder=offset
       andi r2,1                       ; Bit 0 of quotient
       sla  r2,11                      ; * 2048 = name table offset
       a    r2,r0                      ; Add to VDP address
       srl  r3,3                       ; Vertical offset in characters
       mov  r3,r4                      ; Save for draw loop
       sla  r3,5                       ; Vertical address offset
       a    r3,r0                      ; Add to VDP address
       bl   @vwad                      ; Set VDP address
*      Map address
       mov  @scroll_x,r1
       srl  r1,3                       ; Offset in characters
       ci   r1,map_width-1
       jlt  draw_column_0
       li   r1,map_width-1
draw_column_0:
       ai   r1,level_1_map
*      Draw column
       li   r2,map_height
draw_column_1:
       movb *r1,*r15
       ai   r1,map_width
       inc  r4                         ; Increase vertical offset
       ci   r4,screen_height_chars
       jlt  draw_column_2
       andi r0,>81f                    ; To top
       li   r5,>800                    ; Flip page
       xor  r5,r0
       bl   @vwad
       clr  r4
draw_column_2:
       dec  r2
       jne  draw_column_1
*      Reset VDP address increment
       li   r0,>3001                   ; Set VDP address increment
       bl   @vwtr                      ; to 1
draw_column_3:
       .endproc
*// draw_column

*********************************************************************
*
* Move player
*
move_player:
       .proc
       mov  @player_sprite,r4
*      Check joystick
       li   r0,KEY_FI
       bl   @check_key
*      Fire
       jeq  move_player_0
       mov  @player_fire,r0            ; Test if ready
       jne  move_player_1
       seto @player_fire               ; Fire
       jmp  move_player_1
move_player_0:
       clr  @player_fire               ; Set ready
*      Left
move_player_1:
       tb   1
       jeq  move_player_2
       mov  @sprite_y(r4),r0
       ci   r0,73
       jlt  move_player_3
       dec  @sprite_y(r4)
       jmp  move_player_3
*      Right
move_player_2:
       tb   2
       jeq  move_player_3
       mov  @sprite_y(r4),r0
       ci   r0,177
       jgt  move_player_3
       inc  @sprite_y(r4)
*      Down (plane up)
move_player_3:
       tb   3
       jeq  move_player_4
       mov  @sprite_z(r4),r0
       ci   r0,79
       jgt  move_player_5
       inc  @sprite_z(r4)
       jmp  move_player_5
*      Up (plane down)
move_player_4:
       tb   4
       jeq  move_player_5
       mov  @sprite_z(r4),r0
       ci   r0,9
       jlt  move_player_5
       dec  @sprite_z(r4)
move_player_5:
       .endproc
*// move_player

*********************************************************************
*
* Fire
*
fire:
       .proc
       mov  @player_fire,r0
       jeq  fire_1
       jgt  fire_1
       bl   @allocate_sprite
       mov  r4,r5
       jeq  fire_1
       li   r6,sprite_type_green_bullet
       mov  r6,@sprite_type(r5)
       mov  @player_sprite,r4
       bl   @align_sprites
       li   r0,12
       a    r0,@sprite_x(r5)
       neg  @player_fire
fire_1:
       .endproc
*// fire

*********************************************************************
*
* Move sprites
*
move_sprites:
       .proc
       mov  @scroll_pos,r8
       ai   r8,-32
       li   r4,sprites
move_sprites_1:
       c    r4,@sprites_end_ptr
       jhe  move_sprites_4
       mov  @sprite_type(r4),r7
       jeq  move_sprites_3
*      Handler
       mov  @sprite_type_handler(r7),r0
       jeq  move_sprites_2
       bl   *r0
*      Check if out of bounds
move_sprites_2:
       mov  @sprite_x(r4),r0
       a    @sprite_y(r4),r0
       c    r0,r8
       jgt  move_sprites_3
*      Remove
       clr  @sprite_type(r4)           ; Remove sprite
       mov  @sprites_end_ptr,r5
       ai   r5,-sprite_size
       c    r4,r5
       jne  move_sprites_3
       mov  r5,@sprites_end_ptr
*      Next
move_sprites_3:
       ai   r4,sprite_size
       jmp  move_sprites_1
move_sprites_4:
       .endproc
*// move_sprites

*********************************************************************
*
* Player collisions
*
player_collisions:
       .proc
       li   r0,collis
       bl   @vrad
player_collisions_1:
*      Get 1st sprite involved in collision
       movb @vdprd,r4
       swpb r4
       movb @vdprd,r4
       swpb r4
*      Check if it's the player
       c    r4,@player_sprite
       jne  player_collisions_3
*      Get 2nd sprite involved in collision
       movb @vdprd,r5
       swpb r5
       movb @vdprd,r5
       swpb r5
*      Check if 2nd sprite is in fact a wall
       mov  r5,r5
       jeq  player_collisions_2        ; Wall
*      Check if 2nd sprite is lethal
       mov  @sprite_type(r5),r7
       mov  @sprite_type_lethal(r7),r0
       jeq  player_collisions_1
*      Collision
player_collisions_2:
       seto @player_status
player_collisions_3:
       .endproc
*// player_collisions

*********************************************************************
*
* Bullet collisions
*
bullet_collisions:
       .proc
       li   r0,collis
       bl   @vrad
bullet_collisions_1:
*      Get 1st sprite involved in collision
       movb @vdprd,r4
       swpb r4
       movb @vdprd,r4
       swpb r4
       mov  r4,r4
       jeq  bullet_collisions_3
*      Get 2nd sprite involved in collision
       movb @vdprd,r5
       swpb r5
       movb @vdprd,r5
       swpb r5
*      Check if 1st sprite is a bullet
       mov  @sprite_type(r4),r6
       ci   r6,sprite_type_green_bullet
       jne  bullet_collisions_1
*      Check if 2nd sprite is in fact a wall
       mov  r5,r5
       jne  bullet_collisions_2
*      Collision with wall
       bl   @wall_hit_handler
       jmp  bullet_collisions_3
*      Collision with other sprite
bullet_collisions_2:
       mov  @sprite_type(r5),r7
       mov  @sprite_type_hit_handler(r7),r8    ; Can the sprite be hit?
       jeq  bullet_collisions_1
       bl   *r8
bullet_collisions_3:
       .endproc
*// bullet_collisions

*********************************************************************
*
* Create sprites
*
create_sprites:
       .proc
       mov  @sprite_def_ptr,r6
create_sprites_1:
       c    @scroll_x,@sprite_def_scroll_x(r6)
       jl   create_sprites_2
       bl   @create_sprite
       ai   r6,sprite_def_size
       jmp create_sprites_1
create_sprites_2:
       mov  r6,@sprite_def_ptr
       .endproc
*// create_sprites

*********************************************************************
*
* Create sprite
*
* r6: sprite def
*
create_sprite:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_sprite_2
create_sprite_1:
       mov  @sprite_def_type(r6),r7
       mov  r7,@sprite_type(r4)
       mov  @sprite_def_x(r6),@sprite_x(r4)
       mov  @sprite_def_y(r6),@sprite_y(r4)
       mov  @sprite_def_z(r6),@sprite_z(r4)
*      Handler
       mov  @sprite_type_handler(r7),r0
       jeq  create_sprite_2
       seto @sprite_counter(r4)        ; Initial value
       bl   *r0
create_sprite_2:
       .endproc
*// create_sprite

*********************************************************************
*
* Allocate sprite
*
* On return r4 contains the address of the sprites
* or 0 if allocation failed
*
allocate_sprite:
       .proc
       li   r4,sprites
allocate_sprite_1:
       c    r4,@sprites_end_ptr
       jeq  allocate_sprite_2
       mov  @sprite_type(r4),r0
       jeq  allocate_sprite_2
       ai   r4,sprite_size
       jmp  allocate_sprite_1
allocate_sprite_2:
       ci   r4,sprites+(sprite_size*max_sprites)
       jl   allocate_sprite_3
       clr  r4
       jmp  allocate_sprite_4
allocate_sprite_3:
       mov  @sprites_end_ptr,r5
       c    r4,r5
       jne  allocate_sprite_4
       ai   r5,sprite_size
       mov  r5,@sprites_end_ptr
allocate_sprite_4:
       .endproc
*// allocate_sprite

*********************************************************************
*
* Align sprites to the same position
*
* r4: sprite to align to
* r5: sprite to align
*
align_sprites:
       mov  @sprite_x(r4),@sprite_x(r5)
       mov  @sprite_y(r4),@sprite_y(r5)
       mov  @sprite_z(r4),@sprite_z(r5)
       rt
*// allign_sprites

*********************************************************************
*
* Scroll
*
scroll:
       .proc
       inc  @scroll_pos
       mov  @scroll_pos,r1
       li   r0,scrlps                  ; Update VPD variable
       bl   @vsbw                      ; High byte
       movb @r1lb,*r15                 ; Low byte
       mov  r1,@scroll_x
       andi r1,1
       jne  scroll_1
       dec  @scroll_y
scroll_1:
       .endproc
*// scroll

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       bl   @graphics_mode
       bl   @upload_gpu_program
       bl   @upload_sprite_patterns
       .endproc
*// one_time_init

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       li   r1,vdp_registers
graphics_mode_1:
       mov  *r1+,r0
       jlt  graphics_mode_2
       bl   @vwtr                      ; Set register
       jmp  graphics_mode_1
*      Load color palettes
graphics_mode_2:
       li   r0,>2fc0                   ; Reg 47, DPM = 1, AUTO INC = 1, start PR0
       bl   @vwtr
*      Every two bytes written to the VDP now go to the palette registers
       li   r0,PAL0
       LI   r2,128                     ; Each of 64 12-bit palette entries requires 2 bytes
graphics_mode_3:
       movb *r0+,*r15
       dec  r2
       jne  graphics_mode_3
       .endproc
*      VDP registers
vdp_registers:
       byte >39,>1c                    ; Unlock F18A
       byte >39,>1c                    ; Unlock F18A
       byte >00,>00                    ; Graphics I mode
       byte >01,>e2                    ; 16K, display on, interrupt enabled
       byte >02,nametb/>400            ; Name table
       byte >03,tilatb/>40             ; Tile attribute table
       byte >04,ptrntb/>800            ; Pattern table
       byte >05,spratb/>80             ; Sprite attribute table
       byte >06,sprptb/>800            ; Sprite pattern table
       byte >07,backdrop_color         ; Backdrop color
       byte >31,>fb                    ; Reg 49: Enhanced color mode (ECM3 tiles and sprites, 30 rows, tl2, real y coord)
       byte >32,>01                    ; TL2 vs sprite priority considered
       byte >1b,>00                    ; Reg 27: Horizontal scroll offset
       byte >1c,>00                    ; Reg 28: Vertical scroll offset
       byte >1d,>01                    ; Reg 29: Page size (2K between sprite patten tables, 1 x 2 scroll size)
       byte >0a,nam2tb/>400            ; Reg 10: Name table 2
       byte >0b,tilatb/>40             ; Reg 11: Tile attribute table 2
       byte >33,>00                    ; Reg 15: All sprites off
       data -1
*// graphics_mode

*********************************************************************
*
* Init level
*
init_level:
       .proc
       li   r0,>01a2                   ; Display off
       bl   @vwtr
       bl   @clear_vdp_ram
       bl   @init_tl2
       bl   @vsync
       li   r0,>01e2                   ; Display on
       bl   @vwtr
       clr  @scroll_pos
       li   r0,scrlps
       clr  r1
       bl   @vsbw
       clr  *r15
       clr  @scroll_x
       li   r0,>800
       mov  r0,@scroll_y
       li   r0,level_1_000_add
       mov  r0,@char_diff_ptr
       clr  @chars_to_upload
       li   r0,sprites
       mov  r0,@sprites_end_ptr
       li   r0,sprite_defs
       mov  r0,@sprite_def_ptr
       seto @map_bank_select
       clr  @player_fire
       clr  @player_status
*      Create player plane
       li   r6,plane_def
       bl   @create_sprite
       mov  r4,@player_sprite
       li   r6,shadow_def
       bl   @create_sprite
       mov  r4,@player_shadow
       li   r0,sprbuf
       bl   @vwad
       clr  *r15
       clr  *r15
       .endproc
*// init_level

*********************************************************************
*
* Clear VDP RAM up to the sprite pattern table
*
clear_vdp_ram:
       .proc
       clr  r0                         ; Clear name table and pattern tables
       clr  r1
       li   r2,sprptb
       bl   @vsmw
       li   r0,>3300                   ; Disable sprites
       bl   @vwtr
       .endproc
*// clear_vdp_ram

*********************************************************************
*
* Upload sprite patterns
*
upload_sprite_patterns:
       .proc
       seto @sprite_bank_select
       li   r0,sprpt0
       li   r1,>6800
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       li   r0,sprpt1
       li   r1,>7000
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       li   r0,sprpt2
       li   r1,>7800
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       .endproc
*// upload_sprite_patterns

*********************************************************************
*
* Init tile layer 2
*
init_tl2:
       .proc
       li   r0,nam2tb
       li   r1,MD0
       li   r2,960
       bl   @vmbw
       li   r0,ptrnt0+(tl2_first_char*8)
       li   r1,P0_249x
       li   r2,tl2_chars*8
       bl   @vmbw
       li   r0,tilatb+tl2_first_char
       li   r1,TAT249x
       li   r2,tl2_chars
       bl   @vmbw
       .endproc
*// init_tl2

***************************************************************
*
* Includes
*
       copy "gpu.a99"
       copy "vdp.a99"
       copy "sprite-handlers.a99"

lower_memory_max:
       equ  $

***************************************************************
*
* Upper memory
*
       aorg >a000

       copy "diff1.a99"
diff_end:
       copy "tl2.a99"
       copy "chars1.a99"
       copy "tile-attrs.a99"
       copy "sprite-types.a99"
       copy "sprite-defs.a99"
       copy "sprites.a99"
       copy "palettes.a99"

upper_memory_max:
       equ  $

***************************************************************

       end
