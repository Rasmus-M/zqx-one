*********************************************************************
*
* Zaxxon
* For the TI-99/4A home computer with F18A
*
* February 2021 -
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"
       copy "sound-defs.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ  >9000                      ; Speech read
spchwt equ  >9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
name_table_base:                       ; Name table base
       equ  >0000
name_table_p_0:                        ; Name table page 0
       equ  >0000
vdp_variables:                         ; VDP variables
       equ  >03c0
vdp_gpu_status:                        ; GPU status
       equ  >03c0
vdp_scroll_pos:                        ; Scroll position
       equ  >03c2
vdp_sub_level:                         ; Sub-level
       equ  >03c4
tile_attr_table:                       ; Tile attribute table
       equ  >0400
sprite_attr_table:                     ; Sprite attribute table
       equ  >0500
sprite_attr_table_2:                   ; Sprite attribute table 2
       equ  >0580
vdp_sprite_buffer:                    ; Sprite buffer (182 bytes for 18 sprites)
       equ  >0600
name_table_p_1:                        ; Name table page 1
       equ  >0800
vdp_collisions:                        ; Collision results
       equ  >0bc0
name_table_2:                          ; Name table 2 base (64 bytes free)
       equ  >0c00
pattern_table_base:                    ; Pattern table base
       equ  >1000
pattern_table_p_0:                     ; Pattern table plane 0
       equ  >1000
pattern_table_p_1:                     ; Pattern table plane 1
       equ  >1800
pattern_table_p_2:                     ; Pattern table plane 2
       equ  >2000
gpu_prg_tmp:                           ; GPU program temporary location
       equ  >2800
sprite_pattern_table_base:             ; Sprite pattern table base
       equ  >2800
sprite_pattern_table_0:                ; Sprite pattern table plane 0
       equ  >2800
sprite_pattern_table_1:                ; Sprite pattern table plane 1
       equ  >3000
sprite_pattern_table_2:                ; Sprite pattern table plane 2
       equ  >3800
gpu_prg:                               ; GPU program location
       equ  >4000

**
* Constants
*
backdrop_color:
       equ  0
screen_height:
       equ  240
screen_width:
       equ  256
screen_height_chars:
       equ  30
screen_width_chars:
       equ  32
window_width:
       equ  224
window_left:
       equ  16
window_top:
       equ  -36
map_0_width:
       equ  128
map_1_width:
       equ  228
map_2_width:
       equ  288
map_height:
       equ  26
map_0_bank_select:
       equ  >600C
map_1_bank_select:
       equ  >6008
map_2_bank_select:
       equ  >600A
map:
       equ  >6000
tl2_first_char:
       equ  140
tl2_chars:
       equ  256-tl2_first_char
max_sprites:
       equ  18
sprite_patterns_0_bank_select:
       equ  >601c
sprite_patterns_1_bank_select:
       equ  >600e
sprite_patterns_2_bank_select:
       equ  >601e
sprite_patters_base_addr:
       equ  >6800
sprite_create_x:
       equ  255
n_sprite_patterns:
       equ  64
patterns_0_bank_select:
       equ  >601a
patterns_1_bank_select:
       equ  >6010
patterns_2_bank_select:
       equ  >6016
patterns_base_addr:
       equ  >6800
tile_attr_base_addr:
       equ  >6400
max_uploaded_chars_per_frame:
       equ  4
isometric_x0:
       equ  16
isometric_y0:
       equ  80
isometric_z0:
       equ  16
isometric_center_y:
       equ  128
player_start_x:
       equ  -64
player_y_min:
       equ  72
player_y_max:
       equ  178
player_z_max:
       equ  71;
player_z_min:
       equ  8
char_space:
       equ 140
char_zero:
       equ 156
char_zero_high:
       equ  240
char_space_high:
       equ  255
char_mask:
       equ  250
char_life:
       equ  235
char_fuel:
       equ  239
fuel_unit:
       equ  64
fuel_max:
       equ  16*fuel_unit-1
sub_level_0_sprites:
       equ  16

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
sndws  equ  wrksp+>20
stack  equ  sndws+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
**
* PAD variables
*
padvar:
       equ  padcon+2                   ; Start of pad variables
vdp_status:
       equ  padvar
rand_no:
       equ  vdp_status+2
map_width:
       equ  rand_no+2
scroll_pos:
       equ  map_width+2
scroll_x:
       equ  scroll_pos+2
scroll_y:
       equ  scroll_x+2
scroll_max:
       equ  scroll_y+2
player_scale_z:
       equ  scroll_max+2
char_diff_ptr:
       equ  player_scale_z+2
char_diff_end:
       equ  char_diff_ptr+2
chars_to_upload:
       equ  char_diff_end+2
sprite_def_ptr:
       equ  chars_to_upload+2
sprites_end_ptr:
       equ  sprite_def_ptr+2
map_bank_select:
       equ  sprites_end_ptr+2
char_patterns_bank_select:
       equ  map_bank_select+2
sprite_patterns_bank_select:
       equ  char_patterns_bank_select+2
player_sprite:
       equ  sprite_patterns_bank_select+2
player_shadow:
       equ  player_sprite+2
player_fire:
       equ  player_shadow+2
player_died:
       equ  player_fire+2
level:
       equ  player_died+2
sub_level_index:
       equ  level+2
sub_level_data:
       equ  sub_level_index+2
walls_ptr:
       equ  sub_level_data+2
score:
       equ  walls_ptr+2
old_score:
       equ  score+2
high_score:
       equ  old_score+2
old_height:
       equ  high_score+2
fuel:
       equ  old_height+2
old_fuel:
       equ  fuel+2
lives:
       equ  old_fuel+2
music:
       equ  lives+2
tune_no:
       equ  music+2
music_on:
       equ  tune_no+2
boss_active:
       equ  music_on+2
boss_sprite:
       equ  boss_active+2
boss_rocket_hits:
       equ  boss_sprite+2
boss_bonus:
       equ  boss_rocket_hits+2
current_char_zero:
       equ  boss_bonus+2
frames_to_wait:
       equ  current_char_zero+2
extra_life_given:
       equ  frames_to_wait+2
snd_channel_1:
       equ  extra_life_given+2
snd_channel_2:
       equ  snd_channel_1+snd_channel_size
snd_channel_3:
       equ  snd_channel_2+snd_channel_size
snd_channel_4:
       equ  snd_channel_3+snd_channel_size
pad_max:
       equ  snd_channel_4+2

***************************************************************
*
* Lower memory
*
       aorg >2000

***************************************************************
*
* Main program
*
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r15,vdpwd                  ; Constant for writing to VDP
       mov  @rndsd,@rand_no            ; Save random number seed
       bl   @one_time_init
intro:
       bl   @display_intro
start_game:
       bl   @init_game
start_level:
       bl   @init_level
start_sub_level:
       bl   @init_sub_level
run_game_loop:
       bl   @game_loop
*      Check if player died or completed sub-level
       abs  @player_died
       jne  run_game_loop_1
*      Sub level completed
       inc  @sub_level_index
       mov  @sub_level_index,r0
       ci   r0,n_sub_levels
       jne  start_sub_level
*      Level completed
       bl   @display_level_completed
       jmp  start_level
*      Died
run_game_loop_1:
       bl   @play_explosion_1
       li   r0,120
       mov  r0,@frames_to_wait
       bl   @dead_loop
       dec  @lives
       jeq  game_over
       bl   @resurrect_player
       bl   @reposition_player
       jmp  start_sub_level
*      Game over
game_over:
       bl   @display_game_over
       bl   @update_high_scores
       jmp  intro
*// main

*********************************************************************
*
* Game loop
*
game_loop:
       .proc
game_loop_1:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @gpu_run
       bl   @upload_characters
       bl   @draw_column
       bl   @wait_gpu
       bl   @player_collisions
       bl   @bullet_collisions
       bl   @move_player
       bl   @fire
       bl   @move_sprites
       bl   @create_sprites
       bl   @upload_sprites
       bl   @display_height
       bl   @display_score
       bl   @display_fuel
       bl   @snd_player
       bl   @use_fuel
       bl   @display_fuel
       abs  @player_died
       jne  game_loop_2
       bl   @scroll
       c    @scroll_pos,@scroll_max
       jl   game_loop_1
       mov  @boss_active,r0
       jne  game_loop_1
game_loop_2:
       .endproc
*// game_loop

*********************************************************************
*
* Game loop after dying
*
dead_loop:
       .proc
dead_loop_1:
       bl   @vsync
       bl   @gpu_run
       bl   @wait_gpu
       bl   @move_sprites
       bl   @upload_sprites
       bl   @snd_player
       dec  @frames_to_wait
       jne  dead_loop_1
       .endproc
*// dead_loop

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

*********************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Horizontal scroll offset
       mov  @scroll_x,r0
       andi r0,>00ff
       ori  r0,>1b00
       bl   @vwtr
*      Calculate vertical page and offset
       clr  r0
       mov  @scroll_y,r1
       li   r2,screen_height
       div  r2,r0                      ; r0 quotient=pages, r1 remainder=offset
*      Vertical page (name table)
       andi r0,1                       ; Bit 0 of quotient
       sla  r0,1                       ; Shift to select name table
       ori  r0,>0200                   ; Name table
       bl   @vwtr
*      Vertical scroll offset
       mov  r1,r0                      ; Offset
       ori  r0,>1c00
       bl   @vwtr
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Upload sprites
*
upload_sprites:
       .proc
       li   r0,vdp_sprite_buffer
       bl   @vwad
       li   r2,r1lb
       li   r4,sprites
upload_sprites_1:
       c    r4,@sprites_end_ptr
       jeq  upload_sprites_4
       mov  @sprite_type(r4),r6
       jeq  upload_sprites_3
       mov  @sprite_z(r4),r3
       jlt  upload_sprites_3           ; Skip if z < 0
       movb r4,*r15                    ; Sprite address
       movb @r4lb,*r15
       mov  @sprite_type_index(r6),r1  ; Type index
       movb r1,*r15
       movb *r2,*r15
       mov  @sprite_x(r4),r1
       movb r1,*r15
       movb *r2,*r15                   ; Low byte
       mov  @sprite_y(r4),r1
       movb r1,*r15
       movb *r2,*r15                   ; Low byte
       mov  r3,r1                      ; z
       movb r1,*r15
       movb *r2,*r15                   ; Low byte
upload_sprites_3:
       ai   r4,sprite_size
       jmp  upload_sprites_1
upload_sprites_4:
       clr  *r15
       clr  *r15
upload_sprites_5:
       .endproc
*// upload_sprites

*********************************************************************
*
* Upload characters
*
* diff_ptr points to the difference structure
*
upload_characters:
       .proc
       mov  @scroll_x,r0
       andi r0,7
       jne  upload_characters_0
*      Get new characters to upload
       mov  @char_diff_ptr,r5
       c    r5,@char_diff_end
       jhe  upload_characters_3
       clr  r6
       movb *r5+,r6
       jeq  upload_characters_3
       swpb r6
       mov  r6,@chars_to_upload
       mov  r5,@char_diff_ptr
*      Calculate how many characters to upload this frame
upload_characters_0:
       mov  @chars_to_upload,r6
       jeq  upload_characters_4                ; Skip if none left
       ci   r6,max_uploaded_chars_per_frame
       jle  upload_characters_1
       ci   r0,7                               ; At frame 7 we need to finish
       jeq  upload_characters_1
       li   r6,max_uploaded_chars_per_frame    ; Limit number of characters to upload
*      Upload characters
upload_characters_1:
       s    r6,@chars_to_upload
       mov  @char_diff_ptr,r5
upload_characters_2:
       clr  r0
       movb *r5+,r0
       swpb r0
       movb *r5+,r1
       swpb r1
       movb *r5+,r1
       swpb r1
       bl   @upload_character
       dec  r6
       jne  upload_characters_2
upload_characters_3:
       mov  r5,@char_diff_ptr
upload_characters_4:
       .endproc
*// upload_characters

*********************************************************************
*
* Upload character
*
* r0: VDP index
* r1: Global index
*
upload_character:
       .proc
       mov  r0,r3
       mov  r1,r4
*      Select ROM bank
       andi r1,>0300
       srl  r1,7
       a    @char_patterns_bank_select,r1
       seto *r1
*      Tile attribute
       ai   r0,tile_attr_table
       movb @tile_attr_base_addr(r4),r1
       bl   @vsbw
*      Pattern
       mov  r3,r0
       mov  r4,r1
       sla  r0,3
       ai   r0,pattern_table_base
       andi r1,>00ff
       sla  r1,3
       ai   r1,patterns_base_addr
       li   r2,3
upload_character_1:
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       ai   r0,pattern_table_p_1-pattern_table_p_0
       ai   r1,>800-8
       dec  r2
       jne  upload_character_1
       .endproc
*// upload_character

*********************************************************************
*
* Draw column
*
draw_column:
       .proc
       mov  @scroll_x,r0
       andi r0,7
       jne  draw_column_3
*      Select ROM bank
       mov  @map_bank_select,r0
       seto *r0
*      Set VDP address increment
       li   r0,>3020                   ; Set VDP address increment
       bl   @vwtr                      ; to 32
*      Calculate VDP address
       mov  @scroll_x,r0
       ai   r0,window_width+window_left ; Right side of window
       srl  r0,3                       ; Offset in characters
       andi r0,screen_width_chars-1    ; VDP address
*      Vertical
       clr  r2                         ; For division
       mov  @scroll_y,r3               ; Scroll offset
       ai   r3,window_top              ; Draw start
       li   r4,screen_height           ; Divisor
       div  r4,r2                      ; r2 quotient=page, r3 remainder=offset
       andi r2,1                       ; Bit 0 of quotient
       sla  r2,11                      ; * 2048 = name table offset
       a    r2,r0                      ; Add to VDP address
       srl  r3,3                       ; Vertical offset in characters
       mov  r3,r4                      ; Save for draw loop
       sla  r3,5                       ; Vertical address offset
       a    r3,r0                      ; Add to VDP address
       bl   @vwad                      ; Set VDP address
*      Map address
       mov  @scroll_x,r1
       srl  r1,3                       ; Offset in characters
       mov  @map_width,r6
       dec  r6
       c    r1,r6
       jlt  draw_column_0
       mov  r6,r1
draw_column_0:
       ai   r1,map
*      Draw column
       li   r2,map_height
draw_column_1:
       movb *r1,*r15
       a    @map_width,r1
       inc  r4                         ; Increase vertical offset
       ci   r4,screen_height_chars
       jlt  draw_column_2
       andi r0,>81f                    ; To top
       li   r5,>800                    ; Flip page
       xor  r5,r0
       bl   @vwad
       clr  r4
draw_column_2:
       dec  r2
       jne  draw_column_1
*      Reset VDP address increment
       li   r0,>3001                   ; Set VDP address increment
       bl   @vwtr                      ; to 1
draw_column_3:
       .endproc
*// draw_column

*********************************************************************
*
* Move player
*
move_player:
       .proc
       mov  @player_sprite,r4
       li   r1,sprite_type_plane
       abs  @player_scale_z
       jeq  move_player_1
       mov  @sprite_z(r4),r2
       ai   r2,-player_z_min
       andi r2,>30
       srl  r2,3
       mov  @player_sprite_types(r2),r1
*      Check joystick
move_player_1:
       li   r0,KEY_FI
       bl   @check_key
*      Fire
       jeq  move_player_2
       mov  @player_fire,r0            ; Test if ready
       jne  move_player_3
       seto @player_fire               ; Fire
       jmp  move_player_3
move_player_2:
       clr  @player_fire               ; Set ready
*      Left
move_player_3:
       tb   1
       jeq  move_player_4
       mov  @sprite_y(r4),r0
       ci   r0,player_y_min-1
       jlt  move_player_5
       dec  @sprite_y(r4)
       jmp  move_player_5
*      Right
move_player_4:
       tb   2
       jeq  move_player_5
       mov  @sprite_y(r4),r0
       ci   r0,player_y_max-1
       jgt  move_player_5
       inc  @sprite_y(r4)
*      Down (plane up)
move_player_5:
       tb   3
       jeq  move_player_6
       mov  @sprite_z(r4),r2
       ci   r2,player_z_max-1
       jgt  move_player_7
       inc  r2
       mov  r2,@sprite_z(r4)
       li   r1,sprite_type_plane_up
       abs  @player_scale_z
       jeq  move_player_7
       ai   r2,-player_z_min
       andi r2,>30
       srl  r2,3
       mov  @player_sprite_types_up(r2),r1
       jmp  move_player_7
*      Up (plane down)
move_player_6:
       tb   4
       jeq  move_player_7
       mov  @sprite_z(r4),r2
       ci   r2,player_z_min+1
       jlt  move_player_7
       dec  r2
       mov  r2,@sprite_z(r4)
       li   r1,sprite_type_plane_down
       abs  @player_scale_z
       jeq  move_player_7
       ai   r2,-player_z_min
       andi r2,>30
       srl  r2,3
       mov  @player_sprite_types_down(r2),r1
move_player_7:
       mov  r1,@sprite_type(r4)
       .endproc
player_sprite_types:
       data sprite_type_plane_xs
       data sprite_type_plane_s
       data sprite_type_plane_m
       data sprite_type_plane
       data sprite_type_plane
player_sprite_types_up:
       data sprite_type_plane_up_xs
       data sprite_type_plane_up_s
       data sprite_type_plane_up_m
       data sprite_type_plane_up
       data sprite_type_plane_up
player_sprite_types_down:
       data sprite_type_plane_down_xs
       data sprite_type_plane_down_s
       data sprite_type_plane_down_m
       data sprite_type_plane_down
       data sprite_type_plane_down
*// move_player

*********************************************************************
*
* Fire
*
fire:
       .proc
       mov  @player_fire,r0
       jeq  fire_1
       jgt  fire_1
       bl   @allocate_sprite
       mov  r4,r5
       jeq  fire_1
       li   r6,sprite_type_green_bullet
       mov  r6,@sprite_type(r5)
       mov  @player_sprite,r4
       bl   @align_sprites
       li   r0,12
       a    r0,@sprite_x(r5)
       li   r0,3
       a    r0,@sprite_y(r5)
       neg  @player_fire
       bl   @play_shot
fire_1:
       .endproc
*// fire

*********************************************************************
*
* Move sprites
*
move_sprites:
       .proc
       mov  @scroll_pos,r8
       ai   r8,-32
       li   r4,sprites
move_sprites_1:
       c    r4,@sprites_end_ptr
       jhe  move_sprites_4
       mov  @sprite_type(r4),r7
       jeq  move_sprites_3
*      Handler
       mov  @sprite_type_handler(r7),r0
       jeq  move_sprites_2
       bl   *r0
*      Check if out of bounds
move_sprites_2:
       mov  @sprite_x(r4),r0
       a    @sprite_y(r4),r0
       c    r0,r8
       jgt  move_sprites_3
*      Remove
       clr  @sprite_type(r4)           ; Remove sprite
       mov  @sprites_end_ptr,r5
       ai   r5,-sprite_size
       c    r4,r5
       jne  move_sprites_3
       mov  r5,@sprites_end_ptr
*      Next
move_sprites_3:
       ai   r4,sprite_size
       jmp  move_sprites_1
move_sprites_4:
       .endproc
*// move_sprites

*********************************************************************
*
* Player collisions
*
player_collisions:
       .proc
       li   r0,vdp_collisions
       bl   @vrad
player_collisions_1:
*      Get 1st sprite involved in collision
       movb @vdprd,r4
       swpb r4
       movb @vdprd,r4
       swpb r4
*      Check if it's the player
       c    r4,@player_sprite
       jne  player_collisions_3
*      Get 2nd sprite involved in collision
       movb @vdprd,r5
       swpb r5
       movb @vdprd,r5
       swpb r5
*      Check if 2nd sprite is in fact a wall
       mov  r5,r5
       jeq  player_collisions_2        ; Wall
*      Check if 2nd sprite is lethal
       mov  @sprite_type(r5),r7
       mov  @sprite_type_lethal(r7),r0
       jeq  player_collisions_1
*      Collision
player_collisions_2:
       seto @player_died
player_collisions_3:
       .endproc
*// player_collisions

*********************************************************************
*
* Bullet collisions
*
bullet_collisions:
       .proc
       li   r0,vdp_collisions
       bl   @vrad
bullet_collisions_1:
*      Get 1st sprite involved in collision
       movb @vdprd,r4
       swpb r4
       movb @vdprd,r4
       swpb r4
       mov  r4,r4
       jeq  bullet_collisions_3
*      Get 2nd sprite involved in collision
       movb @vdprd,r5
       swpb r5
       movb @vdprd,r5
       swpb r5
*      Check if 1st sprite is a bullet
       mov  @sprite_type(r4),r6
       ci   r6,sprite_type_green_bullet
       jeq  bullet_collisions_1a
*      Check if 2nd sprite is a bullet
       mov  @sprite_type(r5),r6
       ci   r6,sprite_type_green_bullet
       jne  bullet_collisions_1
*      Swap 1st and 2nd
       mov  r4,r0
       mov  r5,r4
       mov  r0,r5
*      Check if 2nd sprite is in fact a wall
bullet_collisions_1a:
       mov  r5,r5
       jne  bullet_collisions_2
*      Collision with wall
       bl   @wall_hit_handler
       jmp  bullet_collisions_3
*      Collision with other sprite
bullet_collisions_2:
       mov  @sprite_type(r5),r7
       mov  @sprite_type_hit_handler(r7),r8    ; Can the sprite be hit?
       jeq  bullet_collisions_1
       bl   *r8
bullet_collisions_3:
       .endproc
*// bullet_collisions

*********************************************************************
*
* Create sprites
*
create_sprites:
       .proc
       mov  @sprite_def_ptr,r6
create_sprites_1:
       c    @scroll_x,@sprite_def_scroll_x(r6)
       jl   create_sprites_2
       bl   @create_sprite
       ai   r6,sprite_def_size
       jmp create_sprites_1
create_sprites_2:
       mov  r6,@sprite_def_ptr
       .endproc
*// create_sprites

*********************************************************************
*
* Create sprite
*
* r6: sprite def
*
create_sprite:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_sprite_2
create_sprite_1:
       mov  @sprite_def_type(r6),r7
       mov  r7,@sprite_type(r4)
       mov  @sprite_def_x(r6),@sprite_x(r4)
       mov  @sprite_def_y(r6),@sprite_y(r4)
       mov  @sprite_def_z(r6),@sprite_z(r4)
*      Handler
       mov  @sprite_type_handler(r7),r0
       jeq  create_sprite_2
       seto @sprite_counter(r4)        ; Initial value
       bl   *r0
create_sprite_2:
       .endproc
*// create_sprite

*********************************************************************
*
* Allocate sprite
*
* On return r4 contains the address of the sprites
* or 0 if allocation failed
*
allocate_sprite:
       .proc
       li   r4,sprites
allocate_sprite_1:
       c    r4,@sprites_end_ptr
       jeq  allocate_sprite_2
       mov  @sprite_type(r4),r0
       jeq  allocate_sprite_2
       ai   r4,sprite_size
       jmp  allocate_sprite_1
allocate_sprite_2:
       ci   r4,sprites+(sprite_size*max_sprites)
       jl   allocate_sprite_3
       clr  r4
       jmp  allocate_sprite_4
allocate_sprite_3:
       mov  @sprites_end_ptr,r5
       c    r4,r5
       jne  allocate_sprite_4
       ai   r5,sprite_size
       mov  r5,@sprites_end_ptr
allocate_sprite_4:
       .endproc
*// allocate_sprite

*********************************************************************
*
* Align sprites to the same position
*
* r4: sprite to align to
* r5: sprite to align
*
align_sprites:
       mov  @sprite_x(r4),@sprite_x(r5)
       mov  @sprite_y(r4),@sprite_y(r5)
       mov  @sprite_z(r4),@sprite_z(r5)
       rt
*// allign_sprites

*********************************************************************
*
* Display height
*
display_height:
       .proc
       mov  @player_sprite,r4
       mov  @sprite_z(r4),r1
       c    r1,@old_height
       jeq  display_height_6
       mov  r1,@old_height
*      Set VDP address increment
       li   r0,>3020                   ; Set VDP address increment
       bl   @vwtr                      ; to 32
*      Set VDP write address
       li   r0,name_table_2+(10*32)
       bl   @vwad
*      Draw empty
       li   r2,player_z_max+1
       s    r1,r2
       mov  r2,r3
       srl  r2,3
       jeq  display_height_2
       li   r0,>fa00                   ; Empty char
display_height_1:
       movb r0,*r15
       dec  r2
       jne  display_height_1
*      Draw half
display_height_2:
       andi r3,>0004
       jeq  display_height_3
       li   r0,>e500                   ; Half char
       movb r0,*r15
*      Draw full
display_height_3:
       srl  r1,3
       jeq  display_height_5
       li   r0,>e600                   ; Full char
display_height_4:
       movb r0,*r15
       dec  r1
       jne  display_height_4
*      Set VDP address increment
display_height_5:
       li   r0,>3001                   ; Set VDP address increment
       bl   @vwtr                      ; to 1
display_height_6:
       .endproc
*// display_height

*********************************************************************
*
* Use fuel
*
use_fuel:
       .proc
       c    @sub_level_data,@sub_level_0_data
       jeq  use_fuel_2
       dec  @fuel
       mov  @fuel,r0
       jeq  use_fuel_1
       ci   r0,4*fuel_unit
       jhe  use_fuel_2
       andi r0,>3f
       jne  use_fuel_2
;      TODO: Play sound
       jmp  use_fuel_2
use_fuel_1
       seto @player_died
use_fuel_2:
       .endproc
*// use_fuel

*********************************************************************
*
* Display fuel
*
display_fuel:
       .proc
       mov  @fuel,r1
       jlt  display_fuel_4
       c    r1,@old_fuel
       jeq  display_fuel_4
       li   r0,name_table_2+(29*32)+16
       bl   @vwad
       mov  r1,r2
       ai   r2,fuel_unit-1
       srl  r2,6                       ; log2(fuel_unit)
       mov  r2,r3
       jeq  display_fuel_2
       li   r0,char_fuel*256
display_fuel_1:
       movb r0,*r15
       dec  r2
       jne  display_fuel_1
display_fuel_2:
       li   r2,fuel_max/fuel_unit
       s    r3,r2
       inc  r2
       jeq  display_fuel_4
       li   r0,char_mask*256
display_fuel_3:
       movb r0,*r15
       dec  r2
       jne  display_fuel_3
display_fuel_4:
       .endproc
*// display_fuel

*********************************************************************
*
* Display score
*
display_score:
       .proc
       mov  @score,r1
       c    r1,@old_score
       jeq  display_score_1
       li   r0,68
       li   r2,5
       bl   @display_decimal_at
       mov  @score,@old_score
       c    @score,@high_score
       jl   display_score_1
       mov  @score,@high_score
       bl   @display_high_score
display_score_1:
       .endproc
*// display_score

*********************************************************************
*
* Scroll
*
scroll:
       .proc
       mov  @scroll_pos,r1
       c    r1,@scroll_max
       jhe  scroll_1
       inc  r1
       mov  r1,@scroll_pos
       li   r0,vdp_scroll_pos          ; Update VPD variable
       bl   @vsww
       mov  r1,@scroll_x
       andi r1,1
       jne  scroll_1
       dec  @scroll_y
scroll_1:
       .endproc
*// scroll

*********************************************************************
*
* One time initializations
*
one_time_init:
       .proc
       bl   @graphics_mode
       bl   @init_tl2_patterns
       bl   @display_tl2_mask
       bl   @upload_gpu_program
       seto @music_on
       li   r1,test_music
       clr  r2
       .endproc
*// one_time_init

*********************************************************************
*
* Initialize game
*
init_game:
       .proc
       clr  @level
       clr  @score
       seto @old_score
       clr  @boss_active
       li   r0,3
       mov  r0,@lives
       clr  @extra_life_given
       .endproc
*// init_game

*********************************************************************
*
* Initialize level
*
init_level:
       .proc
       clr  @sub_level_index
       bl   @resurrect_player
*      Reset sprites
       bl   @reset_sprites
*      Create player plane
       li   r6,plane_def
       bl   @create_sprite
       mov  r4,@player_sprite
       li   r6,shadow_def
       bl   @create_sprite
       mov  r4,@player_shadow
*      Init sprites on sublevel 0
       bl   @init_sprite_defs_0
*      Display height and fuel labels
       bl   @display_tl2_game_labels
       .endproc
*// init_level

*********************************************************************
*
* Resurrect player
*
resurrect_player:
       clr  @player_died
       clr  @player_fire
       seto @old_height
       li   r0,fuel_max
       mov  r0,@fuel
       seto @old_fuel
*// resurrect_player

*********************************************************************
*
* Reposition player
*
reposition_player:
       mov  @player_sprite,r1
       li   r0,plane_def+sprite_def_x
       mov  *r0+,@sprite_x(r1)
       mov  *r0+,@sprite_y(r1)
       mov  *r0+,@sprite_z(r1)
       rt
*// reposition_player

*********************************************************************
*
* Initialize sub-level
*
init_sub_level:
       .proc
       bl   @vsync
*      Change to the sprite attribute table where the player is located
       li   r0,sprite_attr_table_2+2   ; Get pattern byte of first sprite in table 2
       bl   @vsbr
       movb r1,r1                      ; Plane is 0
       jeq  init_sub_level_1
       li   r0,>0500+(sprite_attr_table/>80)      ; Change to table 1
       bl   @vwtr
*      Clear name table and patterns
init_sub_level_1:
       bl   @clear_name_table_and_patterns
*      Reset player x position
       mov  @player_sprite,r1
       li   r0,player_start_x
       mov  r0,@sprite_x(r1)
*      Drop all but 2 first sprites
       li   r0,sprites+(2*sprite_size)
       mov  r0,@sprites_end_ptr
       bl   @upload_sprites
*      Reset scroll position
       clr  @scroll_pos                ; Reset scroll position
       li   r0,vdp_scroll_pos          ; Reset VDP variable
       clr  r1
       bl   @vsbw                      ; High byte
       clr  *r15                       ; Low byte
       clr  @scroll_x                  ; Scroll x
       li   r0,>800                    ; Scroll y
       mov  r0,@scroll_y
*      Init sub-level variables
       clr  @chars_to_upload
       mov  @sub_level_index,r1
       sla  r1,1
       mov  @sub_levels(r1),r1
       mov  r1,@sub_level_data
       mov  *r1+,@map_bank_select
       mov  *r1+,@char_patterns_bank_select
       mov  *r1+,@sprite_patterns_bank_select
       mov  *r1+,@char_diff_ptr
       mov  *r1+,@char_diff_end
       mov  *r1+,@sprite_def_ptr
       mov  *r1+,@map_width
       mov  *r1+,@scroll_max
       mov  *r1+,@player_scale_z
       mov  *r1+,@walls_ptr
*      Load palettes
       clr  r0                         ; Palette index 0
       mov  *r1,r1                     ; Palette address
       li   r2,2                       ; 2 palettes
       bl   @load_palettes
*      Upload sprite patterns
       bl   @upload_sprite_patterns
*      Update VDP variable
       li   r0,vdp_sub_level
       mov  @sub_level_index,r1
       bl   @vsww
*      Display lives
       bl   @display_lives
       .endproc
*// init_sub_level

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       li   r1,vdp_registers
graphics_mode_1:
       mov  *r1+,r0
       jlt  graphics_mode_2
       bl   @vwtr                      ; Set register
       jmp  graphics_mode_1
*      Clear VDP RAM
graphics_mode_2:
       bl   @clear_vdp_ram
*      Load sprite palettes
       li   r0,2
       li   r1,sprite_palettes
       li   r2,6
       bl   @load_palettes
       .endproc
*      VDP registers
vdp_registers:
       byte >39,>1c                    ; Unlock F18A
       byte >39,>1c                    ; Unlock F18A
       byte >00,>00                    ; Graphics I mode
       byte >01,>e2                    ; 16K, display on, interrupt enabled
       byte >02,name_table_base/>400   ; Name table
       byte >03,tile_attr_table/>40    ; Tile attribute table
       byte >04,pattern_table_base/>800 ; Pattern table
       byte >05,sprite_attr_table/>80  ; Sprite attribute table
       byte >06,sprite_pattern_table_base/>800 ; Sprite pattern table
       byte >07,backdrop_color         ; Backdrop color
       byte >31,>fb                    ; Reg 49: Enhanced color mode (ECM3 tiles and sprites, 30 rows, tl2, real y coord)
       byte >32,>00                    ; TL2 always on top
       byte >1b,>00                    ; Reg 27: Horizontal scroll offset
       byte >1c,>00                    ; Reg 28: Vertical scroll offset
       byte >1d,>01                    ; Reg 29: Page size (2K between sprite patten tables, 1 x 2 scroll size)
       byte >0a,name_table_2/>400      ; Reg 10: Name table 2
       byte >0b,tile_attr_table/>40    ; Reg 11: Tile attribute table 2
       byte >33,>00                    ; Reg 15: All sprites off
       data -1
*// graphics_mode

*********************************************************************
*
* Clear VDP RAM
*
clear_vdp_ram
       .proc
       clr  r1
       li   r2,>4000
       bl   @vclr
       .endproc
*// clear_vdp_ram

*********************************************************************
*
* Upload sprite patterns
*
upload_sprite_patterns:
       .proc
       mov  @sprite_patterns_bank_select,r0
       seto *r0
       li   r0,sprite_pattern_table_0
       li   r1,sprite_patters_base_addr
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       li   r0,sprite_pattern_table_1
       li   r1,sprite_patters_base_addr+>800
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       li   r0,sprite_pattern_table_2
       li   r1,sprite_patters_base_addr+>1000
       li   r2,n_sprite_patterns*32
       bl   @vmbw
       .endproc
*// upload_sprite_patterns

*********************************************************************
*
* Display tile layer 2 mask
*
display_tl2_mask:
       .proc
       li   r0,name_table_2
       li   r1,MD0
       li   r2,960
       bl   @vmbw
       .endproc
*// display_tl2_mask

*********************************************************************
*
* Clear name table and tile patterns
*
clear_name_table_and_patterns:
       .proc
       li   r0,pattern_table_p_0
       li   r2,>800-(tl2_chars*8)
       bl   @vclr
       li   r0,pattern_table_p_1
       li   r2,>800-(tl2_chars*8)
       bl   @vclr
       li   r0,pattern_table_p_2
       li   r2,>800-(tl2_chars*8)
       bl   @vclr
       li   r0,name_table_p_0
       li   r2,>3c0
       bl   @vclr
       li   r0,name_table_p_1
       li   r2,>3c0
       bl   @vclr
       .endproc
*// clear_name_table_and_patterns

*********************************************************************
*
* Reset sprites
*
reset_sprites:
       .proc
       li   r0,sprites
       mov  r0,@sprites_end_ptr
*      Reset sprite buffer in VDP RAM
       li   r0,vdp_sprite_buffer
       bl   @vwad
       clr  *r15
       clr  *r15
*      Run GPU
       bl   @gpu_run
       .endproc
*// reset_sprites

*********************************************************************
*
* Clear tl2 except scores at top
*
clear_tl2:
       .proc
       li   r0,8*32+name_table_2
       li   r1,8*32+MD0
       li   r2,24*32
       bl   @vmbw
       .endproc
*// clear_tl2

*********************************************************************
*
* Init tile layer 2 patterns
*
init_tl2_patterns:
       .proc
       li   r0,pattern_table_p_0+(tl2_first_char*8)
       li   r1,P0_140
       li   r2,tl2_chars*8
       bl   @vmbw
       li   r0,pattern_table_p_1+(tl2_first_char*8)
       li   r1,P1_140
       li   r2,tl2_chars*8
       bl   @vmbw
       li   r0,pattern_table_p_2+(tl2_first_char*8)
       li   r1,P2_140
       li   r2,tl2_chars*8
       bl   @vmbw
       li   r0,tile_attr_table+tl2_first_char
       li   r1,TAT140
       li   r2,tl2_chars
       bl   @vmbw
       .endproc
*// init_tl2_patterns

*********************************************************************
*
* Display tile layer 2 game labels
*
display_tl2_game_labels:
       .proc
       li   r3,tl2_labels
display_tl2_game_labels_1:
       mov  *r3+,r0
       jeq  display_tl2_game_labels_3
       ai   r0,name_table_2
       bl   @vwad
display_tl2_game_labels_2
       movb *r3+,r0
       jeq  display_tl2_game_labels_1
       movb r0,*r15
       jmp  display_tl2_game_labels_2
display_tl2_game_labels_3:
       .endproc
tl2_labels:
       data 9*32                       ; Offset
       byte 228,0                      ; Zero-terminated characters to display
       data 19*32
       byte 231,0
       data 29*32+14
       byte 236,237,0
       data 0
*// display_tl2_game_labels

*********************************************************************
*
* Load palettes
*
* r0: Start palette index
* r1: Color data
* r2: Number of palettes
*
load_palettes:
       .proc
       sla  r0,3                       ; 8 bytes per palette
       ori  r0,>2fc0                   ; Reg 47, DPM = 1, AUTO INC = 1
       bl   @vwtr
       sla  r2,4                       ; 16 bytes per palette
*      Every two bytes written to the VDP now go to the palette registers
load_palettes_1:
       movb *r1+,*r15
       dec  r2
       jne  load_palettes_1
*      Exit DPM
       li   r0,>2f00                   ; Reg 47, DPM = 1, AUTO INC = 0
       bl   @vwtr
       .endproc
*// load_palettes

*********************************************************************
*
* Init sprites on sub-level 0 (open space)
*
init_sprite_defs_0:
       .proc
       li   r2,sub_level_0_sprites
       li   r3,sprite_defs_0
       li   r4,240                     ; x
init_sprite_defs_0_1:
       bl   @rand
       andi r0,7
       jeq  init_sprite_defs_0_2
       bl   @rand
       mov  r0,r5
       andi r5,127
       ai   r5,isometric_center_y-64   ; y
       li   r6,64                      ; z
       li   r7,sprite_type_blue_plane_up_l
       jmp  init_sprite_defs_0_3
init_sprite_defs_0_2:
       li   r5,255
       li   r6,64
       li   r7,sprite_type_satellite
init_sprite_defs_0_3:
       mov  r4,r0                      ; x
       a    r5,r0                      ; x + y
       ai   r0,-240                    ; scroll_x = x + y - 240
       mov  r0,*r3+                    ; Write scroll_x
       mov  r4,*r3+                    ; Write x
       mov  r5,*r3+                    ; Write y
       mov  r6,*r3+                    ; Write z
       mov  r7,*r3+                    ; Write sprite type
       ai   r4,48
       dec  r2
       jne  init_sprite_defs_0_1
       .endproc
*// init_sprite_defs_0

*********************************************************************
*
* Display intro
*
display_intro:
       .proc
display_intro_1:
       bl   @clear_for_intro
*      Press fire to start
       li   r0,8*32+6
       li   r1,txt_press_fire_to_start
       bl   @display_text_at
*      High score
       bl   @display_high_scores
       li   r0,240
       bl   @wait
       bl   @clear_tl2
       mov  @frames_to_wait,r0
       jne  display_intro_3
*      Initial demo run
       bl   @init_level
       bl   @init_sub_level
       li   r0,128
       bl   @intro_loop
       mov  r0,r0
       jne  display_intro_2
*      Title
       bl   @display_title
       li   r0,180
       bl   @wait
       bl   @clear_title
       mov  @frames_to_wait,r0
       jne  display_intro_3
*      Continue demo flight
       li   r0,512
       bl   @intro_loop
       mov  r0,r0
       jeq  display_intro_1
display_intro_2:
       bl   @clear_title
display_intro_3:
       .endproc
*// display_intro

*********************************************************************
*
* Clear for intro
*
clear_for_intro:
       .proc
       bl   @clear_name_table_and_patterns
       bl   @reset_sprites
       bl   @clear_tl2
       bl   @init_tl2_patterns
       .endproc
*// clear_for_intro

*********************************************************************
*
* Run intro loop
*
* r0: Run until the screen has scrolled to this position
*
intro_loop:
       .proc
       mov  r0,@scroll_max
intro_loop_1:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @gpu_run
       bl   @upload_characters
       bl   @draw_column
       bl   @wait_gpu
       bl   @player_collisions
       bl   @bullet_collisions
       bl   @intro_move_player
       bl   @fire
       bl   @move_sprites
       bl   @create_sprites
       bl   @upload_sprites
       bl   @display_height
       bl   @display_fuel
       bl   @snd_player
       bl   @scroll
       abs  @player_died
       jne  intro_loop_2
       li   r0,KEY_FI
       bl   @check_key
       jne  intro_loop_2
       c    @scroll_pos,@scroll_max
       jl   intro_loop_1
       clr  r0
       jmp  intro_loop_3
intro_loop_2:
       seto r0
intro_loop_3:
       .endproc
*// intro_loop

*********************************************************************
*
* Move player
*
intro_fire_speed:
       equ  30
*
intro_move_player:
*      Fire
       dec  @intro_fire_countdown
       jne  intro_move_player_1
       seto @player_fire               ; Fire
       li   r0,intro_fire_speed
       mov  r0,@intro_fire_countdown
intro_move_player_1:
       rt
intro_fire_countdown:
       data intro_fire_speed
*// intro_move_player

*********************************************************************
*
* Update high scores
*
update_high_scores:
       c    @high_score,@high_scores
       jle  update_high_scores_2
       li   r0,high_scores+8
       li   r1,high_scores+10
       li   r2,5
update_high_scores_1:
       mov  *r0,*r1
       dect r0
       dect r1
       dec  r2
       jne  update_high_scores_1
       mov  @high_score,@high_scores
update_high_scores_2:
       rt
*// update_high_scores

*********************************************************************
*
* Display high score
*
display_high_scores:
       .proc
*      High scores text
       li   r0,14*32+10
       li   r1,txt_high_scores
       bl   @display_text_at
*      6 high scores
       li   r0,char_zero
       mov  r0,@current_char_zero
       li   r4,1
       li   r5,high_score_positions
       li   r6,high_scores
display_high_scores_1:
       mov  *r5+,r0
       ai   r0,name_table_2
       mov  r4,r1
       ai   r1,char_zero_high
       swpb r1
       bl   @vsbw
       li   r1,char_space*256
       movb r1,*r15
       mov  *r6+,r1
       li   r2,5
       bl   @display_decimal
       ai   r1,char_zero
       movb r1,*r15
       swpb r1
       inc  r4
       ci   r4,6
       jle  display_high_scores_1
*      Best high score at top of screen
       li   r0,char_zero_high
       mov  r0,@current_char_zero
       mov  @high_scores,@high_score
       bl   @display_high_score
       .endproc
high_score_positions:
       data 16*32+5
       data 18*32+5
       data 20*32+5
       data 16*32+19
       data 18*32+19
       data 20*32+19
*// display_high_scores

*********************************************************************
*
* Display best high score at top of screen
*
display_high_score:
       .proc
       li   r0,4
       mov  @high_score,r1
       li   r2,5
       bl   @display_decimal_at
       .endproc
*// display_high_score

*********************************************************************
*
* Display lives
*
max_displayed_lives:
       equ  8
*
display_lives:
       .proc
       li   r0,(30-max_displayed_lives)*32+name_table_2
       li   r1,max_displayed_lives
display_lives_1:
       bl   @vwad
       c    @lives,r1
       jhe  display_lives_2
       li   r2,char_mask*256
       jmp  display_lives_3
display_lives_2:
       li   r2,char_life*256
display_lives_3:
       movb r2,*r15
       ai   r0,32
       dec  r1
       jne  display_lives_1
       .endproc
*// display_lives

*********************************************************************
*
* Display title
*
display_title:
       .proc
       li   r3,title
       mov  r3,@title_ptr
display_title_1:
       li   r0,2
       bl   @wait
       mov  r0,r0
       jne  display_title_2
       mov  @title_ptr,r3
       movb *r3+,r0                    ; x
       jlt  display_title_2
       srl  r0,8
       movb *r3+,r1
       srl  r1,8
       sla  r1,5
       a    r1,r0
       ai   r0,name_table_2
       movb *r3+,r1
       bl   @vsbw
       mov  r3,@title_ptr
       jmp  display_title_1
display_title_2:
       .endproc
title_ptr:
       data 0
*// display_title

*********************************************************************
*
* Clear title area
*
clear_title:
       .proc
       li   r0,12*32+2+name_table_2
       li   r1,char_space_high*256
       li   r3,8
clear_title_1:
       bl   @vwad
       li   r2,28
clear_title_2:
       movb  r1,*r15
       dec  r2
       jne  clear_title_2
       ai   r0,32
       dec  r3
       jne  clear_title_1
       .endproc
*// clear_title

*********************************************************************
*
* Display level completed
*
display_level_completed:
       .proc
       bl   @clear_for_intro
       li   r0,12*32+8
       li   r1,txt_congratulations
       bl   @display_text_at
       li   r0,15*32+5
       li   r1,txt_you_get_bonus
       bl   @display_text_at
       mov  @boss_bonus,r0
       ci   r0,boss_bonus_200
       jne  display_level_completed_1
       li   r0,15*32+19
       li   r1,txt_200_pts
       bl   @display_text_at
       li   r0,18*32+14
       li   r1,txt_good
       bl   @display_text_at
       jmp  display_level_completed_2
display_level_completed_1:
       li   r0,15*32+19
       li   r1,txt_1000_pts
       bl   @display_text_at
       li   r0,18*32+11
       li   r1,txt_very_good
       bl   @display_text_at
display_level_completed_2:
       bl   @wait_fire_key_relased
       li   r0,240
       bl   @wait
       bl   @clear_title
       .endproc
*// display_level_completed

*********************************************************************
*
* Display game over
*
display_game_over:
       .proc
       bl   @clear_for_intro
       li   r0,14*32+11
       li   r1,txt_game_over
       bl   @display_text_at
       bl   @wait_fire_key_relased
       li   r0,240
       bl   @wait
       .endproc
*// display_game_over

*********************************************************************
*
* Add score
*
* r0: score to add
* Modifies r0-r1
*
add_score:
       .proc
       a    r0,@score
       mov  @score,r0
       abs  @extra_life_given
       jne  add_score_1
       ci   r0,1000                    ; Displayed as 10000
       jl   add_score_1
       inc  @lives
       .push r2
       bl   @display_lives
       .pop r2
       seto @extra_life_given
add_score_1:
       .endproc
*// add_score

*********************************************************************
*
* Check key
*
* r0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
JOY_FI EQU  >0606
JOY_LT EQU  >0608
JOY_RT EQU  >060A
JOY_DN EQU  >060C
JOY_UP EQU  >060E
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       rt
*// check_key

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r1,31873                   ; Add a prime number
       src  r1,7                       ; Shift to break odd/even pattern
       mov  r1,@rand_no
       mov  r1,r0
       rt
*// rand

*********************************************************************
*
* Set screen address and display decimal number
*
* r0: Screen offset
* r1: Number to display
* r2: Number of digits
*
display_decimal_at:
       .proc
       ai   r0,name_table_2
       bl   @vwad
       bl   @display_decimal
       .endproc
*// display_decimal_at

*********************************************************************
*
* Display decimal number
*
* r1: Number to display
* r2: Number of digits
*
display_decimal:
       li   r3,5
       s    r2,r3
       sla  r3,1
       ai   r3,d10000
       dec  r2
display_decimal_1:
       clr  r0
       div  *r3+,r0
       a    @current_char_zero,r0
       swpb r0
       movb r0,*r15
       dec  r2
       jne  display_decimal_1
       a    @current_char_zero,r1
       swpb r1
       mov  r1,*r15
       rt
d10000:
       data 10000
d1000:
       data 1000
d100:
       data 100
d10:
       data 10
*// display_decimal

*********************************************************************
*
* Display text at position
*
* r0: Screen offset
* r1: Zero terminated string to display
*
display_text_at:
       .proc
       ai   r0,name_table_2
       bl   @vwad
       li   r0,(char_space-32)*256
display_text_at_1:
       movb *r1+,r2
       jeq  display_text_at_2
       ab   r0,r2
       movb r2,*r15
       jmp  display_text_at_1
display_text_at_2:
       .endproc
*// display_text_at

*********************************************************************
*
* Wait
*
* r0: Frames to wait
*
wait:
       .proc
       mov  r0,@frames_to_wait
wait_1:
       bl   @vsync
       bl   @gpu_run
       bl   @snd_player
       li   r0,KEY_FI
       bl   @check_key
       jne  wait_2
       dec  @frames_to_wait
       jne  wait_1
       clr  r0
       jmp  wait_3
wait_2:
       seto r0
wait_3:
       .endproc
*// wait

*********************************************************************
*
* Wait fire key released
*
wait_fire_key_relased:
       .proc
       li   r0,8
       mov  r0,@frames_to_wait
wait_fire_key_relased_1:
       bl   @vsync
       bl   @gpu_run
       bl   @snd_player
       li   r0,KEY_FI
       bl   @check_key
       jne  wait_fire_key_relased_1
       dec  @frames_to_wait
       jne  wait_fire_key_relased_1
       .endproc
*// wait_fire_key_relased

***************************************************************
*
* Includes
*
       copy "gpu.a99"
       copy "vdp.a99"
       copy "sprite-handlers.a99"

lower_memory_max:
       equ  $

***************************************************************
*
* Upper memory
*
       aorg >a000

       copy "sound-fx-routines.a99"
       copy "sound-fx.a99"
       copy "sound-player.a99"
       copy "sub-levels.a99"
       copy "diff0.a99"
diff_end_0:
       copy "diff1.a99"
diff_end_1:
       copy "diff2.a99"
diff_end_2:
       copy "tl2.a99"
       copy "title.a99"
       copy "sprite-types.a99"
       copy "sprite-defs.a99"
       copy "sprites.a99"
       copy "palettes.a99"
       copy "text.a99"
test_music:
       bcopy "../audio/level3.sbf"
test_sfx:
       bcopy "../audio/shot1.sbf"
*      Scores are automatically multiplied by 10
high_scores:
       data 890
       data 740
       data 660
       data 510
       data 430
       data 370
upper_memory_max:
       equ  $

***************************************************************

       end
