*********************************************************************
*
* Zaxxon
* For the TI-99/4A home computer with F18A
*
* February 2021 -
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ	>9000                      ; Speech read
spchwt equ	>9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
nametb equ	>0000				       ; Name table base
namet0 equ	>0000				       ; Name table page 0 (64 bytes free)
namet1 equ	>0400				       ; Name table page 1 (64 bytes free)
namet2 equ	>0800				       ; Name table page 2 (64 bytes free)
namet3 equ	>0C00				       ; Name table page 3 (64 bytes free)
ptrntb equ	>1000				       ; Pattern table base
ptrnt0 equ	>1000				       ; Pattern table plane 0
ptrnt1 equ	>1800				       ; Pattern table plane 1
ptrnt2 equ	>2000				       ; Pattern table plane 2
sprptb equ	>2800				       ; Sprite pattern table base
sprpt0 equ	>2800				       ; Sprite pattern table plane 0
sprpt1 equ	>2c00				       ; Sprite pattern table plane 1
sprpt2 equ	>3000				       ; Sprite pattern table plane 2
nam2tb equ  >3800                      ; Name table 2 base (64 bytes free)
tilatb equ	>3c00				       ; Tile attribute table
spratb equ	>3d00				       ; Sprite attribute table
                                       ; (640 bytes free)
**
* Constants
*
backdrop_color:
       equ  0
screen_height:
       equ  240
screen_width:
       equ  256
screen_height_chars:
       equ  30
screen_width_chars:
       equ  32
window_width:
       equ  224
window_left:
       equ  16
window_top:
       equ  -36
map_width:
       equ  285
map_height:
       equ  26
map_size:
       equ  map_width*map_height
tl2_first_char:
       equ  250
tl2_chars:
       equ  6

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  r15lb+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
**
* PAD variables
*
padvar:
       equ  padcon+2                   ; Start of pad variables
vdp_status:
       equ  padvar
scroll_x:
       equ  vdp_status+2
scroll_y:
       equ  scroll_x+2
diff_ptr:
       equ  scroll_y+2
pad_max:
       equ  diff_ptr+2

***************************************************************
*
* Upper memory
*
       aorg >a000

***************************************************************
*
* Main program
*
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r15,vdpwd                  ; Constant for writing to VDP
       bl   @graphics_mode
restart:
       bl   @init_level
loop:
       bl   @vsync
       bl   @set_vdp_regs
       mov  @scroll_x,r0
       andi r0,7
       jne  !
       bl   @upload_characters
       bl   @draw_column
!:
       bl   @scroll
       c    @scroll_x,@scroll_max
       jl   loop
       jmp  restart

scroll_max:
       data map_width*8-window_width-window_left

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

*********************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*	   Calculate vertical page and offset
       clr  r1
       mov	@scroll_y,r2
       li	r3,screen_height
       div	r3,r1				       ; r1 quotient, r2 remainder
*	   Horizontal scroll offset
       mov	@scroll_x,r0
       andi	r0,>00ff
       ori	r0,>1b00
       bl	@vwtr
*	   Vertical scroll offset
       mov	r2,r0
       ori	r0,>1c00
       bl	@vwtr
*	   Horizontal page start
       mov	@scroll_x,r0
       andi	r0,screen_width			   ; Isolate bit value 256
       swpb	r0					       ; Shift to bit 0
*	   Vertical page start
       andi	r1,1				       ; Bit 0 of quotient
       sla	r1,1				       ; Shift to bit 1
       soc	r1,r0				       ; Combine with horizontal bit
*	   Set current name table
       ori	r0,>0200			       ; Name table
       bl	@vwtr
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Upload characters
*
* diff_ptr points to the difference structure
*
upload_characters:
       .proc
       mov  @diff_ptr,r5
       ci   r5,diff_end
       jh   upload_characters_2
       clr  r6
       movb *r5+,r6
       jeq  upload_characters_2
       swpb r6
upload_characters_1:
       clr  r0
       movb *r5+,r0
       swpb r0
       movb *r5+,r1
       swpb r1
       movb *r5+,r1
       swpb r1
       bl   @upload_character
       dec  r6
       jne  upload_characters_1
upload_characters_2:
       mov  r5,@diff_ptr
       .endproc
*// upload_characters

*********************************************************************
*
* Upload character
*
* r0: VDP index
* r1: Global index
*
upload_character:
       .proc
       mov  r0,r3
       mov  r1,r4
*      Tile attribute
       ai   r0,tilatb
       movb @TAT0(r1),r1
       bl   @vsbw
*      Pattern
       mov  r3,r0
       mov  r4,r1
       sla  r0,3
       ai   r0,ptrntb
       sla  r1,3
       ai   r1,P0_0
       li   r2,3
upload_character_1:
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       ai   r0,ptrnt1-ptrnt0
       ai   r1,P1_0-P0_0-8
       dec  r2
       jne  upload_character_1
       .endproc
*// upload_character

*********************************************************************
*
* Draw column
*
draw_column:
       .proc
*      Set VDP address increment
       li   r0,>3020                   ; Set VDP address increment
       bl   @vwtr                      ; to 32
*      Calculate VDP address
       mov  @scroll_x,r0
       ai   r0,window_width+window_left ; Right side of window
       mov  r0,r1
       andi r0,screen_width            ; 0 or 256
       sla  r0,2                       ; Name table offset (0 or 1024)
       srl  r1,3                       ; Offset in characters
       andi r1,screen_width_chars-1
       a    r1,r0                      ; Add to VDP address
*      Vertical
       clr  r2                         ; For division
       mov	@scroll_y,r3               ; Scroll offset
       ai   r3,window_top
       li	r4,screen_height           ; Divided by screen height
       div	r4,r2				       ; r2 quotient, r3 remainder
       andi r2,1                       ; Bit 0 of quotient
       sla  r2,11                      ; Name table offset
       a    r2,r0                      ; Add to VDP address
       srl  r3,3                       ; Vertical offset in characters
       mov  r3,r4
       sla  r3,5                       ; Vertical address offset
       a    r3,r0                      ; Add to VDP address
       bl   @vwad                      ; Set VDP address
*      Map address
       mov  @scroll_x,r1
       ai   r1,window_width            ; Offset to start column
       srl  r1,3                       ; Offset in characters
       ai   r1,level_1_map
*      Draw column
       li   r2,map_height
draw_column_1:
       movb *r1,*r15
       ai   r1,map_width
       inc  r4                         ; Increase vertical offset
       ci   r4,screen_height_chars
       jlt  draw_column_2
       andi r0,>c1f
       li   r5,>800
       xor  r5,r0
       bl   @vwad
       clr  r4
draw_column_2:
       dec  r2
       jne  draw_column_1
*      Reset VDP address increment
       li   r0,>3001                   ; Set VDP address increment
       bl   @vwtr                      ; to 1
       .endproc
*// draw_column

*********************************************************************
*
* Scroll
*
scroll:
       .proc
       mov  @scroll_x,r0
       inc  r0
       mov  r0,@scroll_x
       andi r0,1
       jne  scroll_1
       dec  @scroll_y
scroll_1:
       .endproc
*// scroll

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       li   r1,vdp_registers
graphics_mode_1:
       mov  *r1+,r0
       jlt  graphics_mode_2
       bl   @vwtr                      ; Set register
       jmp  graphics_mode_1
*	   Load color palettes
graphics_mode_2:
       li   r0,>2fc0			       ; Reg 47, DPM = 1, AUTO INC = 1, start PR0
       bl   @vwtr
*      Every two bytes written to the VDP now go to the palette registers
       li   r0,PAL0
       LI   r2,128				       ; Each of 64 12-bit palette entries requires 2 bytes
graphics_mode_3:
       movb *r0+,*r15
       dec  r2
       jne  graphics_mode_3
;       li   r0,>2F00			       ; Reg 47, exit DMP
;       bl   @vwtr				       ; (should happen automatically after writing to PR63)
       .endproc
*      VDP registers
vdp_registers:
       byte >39,>1c                    ; Unlock F18A
       byte >39,>1c                    ; Unlock F18A
       byte >00,>00                    ; Graphics I mode
       byte >01,>e2                    ; 16K, display on, interrupt enabled
       byte >02,nametb/>400            ; Name table
       byte >03,tilatb/>40             ; Tile attribute table
       byte >04,ptrntb/>800            ; Pattern table
       byte >05,spratb/>80             ; Sprite attribute table
       byte >06,sprptb/>800            ; Sprite pattern table
       byte >07,backdrop_color         ; Backdrop color
       byte >31,>f3                    ; Reg 49: Enhanced color mode (ECM3 tiles and sprites, 30 rows, tl2)
       byte >1b,>00                    ; Reg 27: Horizontal scroll offset
       byte >1c,>00                    ; Reg 28: Vertical scroll offset
       byte >1d,>13                    ; Reg 29: Page size (1K between sprite patten tables, 2 x 2 scroll size)
       byte >0a,nam2tb/>400            ; Reg 10: Name table 2
       byte >0b,tilatb/>40             ; Reg 11: Tile attribute table 2
       data -1
*// graphics_mode

*********************************************************************
*
* Init level
*
init_level:
       .proc
       li   r0,>01a2                   ; Displaÿ off
       bl   @vwtr
       bl   @clear_vdp_ram
       bl   @init_tl2
       bl   @vsync
       li   r0,>01e2                   ; Displaÿ on
       bl   @vwtr
       clr  @scroll_x
       li   r0,>800
       mov  r0,@scroll_y
       li   r0,level_1_000_add
       mov  r0,@diff_ptr
       .endproc
*// init_level

*********************************************************************
*
* Clear VDP RAM
*
clear_vdp_ram:
       .proc
       clr  r0                         ; Clear name table and pattern tables
       clr  r1
       li   r2,>2800
       bl   @vsmw
       li   r0,>3800                   ; Clear name table 2, tile attribute list, SAL
       li   r2,>800
       bl   @vsmw
       li   r0,spratb                  ; Disable sprites
       li   r1,>d000
       bl   @vsbw
       .endproc
*//clear_vdp_ram

*********************************************************************
*
* Init tile layer 2
*
init_tl2:
       .proc
       li   r0,nam2tb
       li   r1,MD0
       li   r2,960
       bl   @vmbw
       li   r0,ptrnt0+(tl2_first_char*8)
       li   r1,P0_250x
       li   r2,tl2_chars*8
       bl   @vmbw
       li   r0,tilatb+tl2_first_char
       li   r1,TAT250x
       li   r2,tl2_chars
       bl   @vmbw
       .endproc
*// init_tl2

***************************************************************
*
* Includes
*
       copy "vdp.a99"
       copy "chars1.a99"
       copy "tl2.a99"
       copy "diff1.a99"
*      copy "sprites.a99"
diff_end:
       equ  $

upper_memory_max:
       equ  $

***************************************************************
*
* Lower memory
*
       aorg >2000

       copy "map1.a99"

lower_memory_max:
       equ  $

***************************************************************

       end
