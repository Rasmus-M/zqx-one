*********************************************************************
*
* Zaxxon
* For the TI-99/4A home computer with F18A
*
* February 2021 -
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*

       copy "macros.a99"

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400                      ; PSG sound
spchrd equ  >9000                      ; Speech read
spchwt equ  >9400                      ; Speech write
grmrd  equ  >9800                      ; GROM read data
grmra  equ  >9802                      ; GROM address read
grmwd  equ  >9C00                      ; GROM write data
grmwa  equ  >9C02                      ; GROM address write

**
* VDP memory map
*
nametb equ  >0000                      ; Name table base
namet0 equ  >0000                      ; Name table page 0 (64 bytes free)
namet1 equ  >0400                      ; Name table page 1 (64 bytes free)
namet2 equ  >0800                      ; Name table page 2 (64 bytes free)
namet3 equ  >0C00                      ; Name table page 3 (64 bytes free)
ptrntb equ  >1000                      ; Pattern table base
ptrnt0 equ  >1000                      ; Pattern table plane 0
ptrnt1 equ  >1800                      ; Pattern table plane 1
ptrnt2 equ  >2000                      ; Pattern table plane 2
nam2tb equ  >2800                      ; Name table 2 base (64 bytes free)
tilatb equ  >2c00                      ; Tile attribute table
spratb equ  >2d00                      ; Sprite attribute table (640 bytes free)
sprptb equ  >3000                      ; Sprite pattern table base
sprpt0 equ  >3000                      ; Sprite pattern table plane 0
sprpt1 equ  >3400                      ; Sprite pattern table plane 1
sprpt2 equ  >3800                      ; Sprite pattern table plane 2 (1024 byte free)
;sprpt1 equ  >3800                      ; Sprite pattern table plane 1
;sprpt2 equ  >4000                      ; Sprite pattern table plane 2

**
* Constants
*
backdrop_color:
       equ  0
screen_height:
       equ  240
screen_width:
       equ  256
screen_height_chars:
       equ  30
screen_width_chars:
       equ  32
window_width:
       equ  224
window_left:
       equ  16
window_top:
       equ  -36
map_width:
       equ  228
map_height:
       equ  26
map_size:
       equ  map_width*map_height
tl2_first_char:
       equ  250
tl2_chars:
       equ  6
max_sprites:
       equ  8
gpu_run:
       equ  nam2tb
level_1_map:
       equ  >6000
map_bank_select:
       equ  >6008
sprite_create_x:
       equ  255

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; Low byte of register 0
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
r10lb  equ  wrksp+21
r11lb  equ  wrksp+23
r12lb  equ  wrksp+25
r13lb  equ  wrksp+27
r14lb  equ  wrksp+29
r15lb  equ  wrksp+31
stack  equ  wrksp+>20                  ; Stack (grows up)
**
* PAD constants
*
padcon:
       equ  stack+>10                  ; Start of pad constants
**
* PAD variables
*
padvar:
       equ  padcon+2                   ; Start of pad variables
vdp_status:
       equ  padvar
scroll_x:
       equ  vdp_status+2
scroll_y:
       equ  scroll_x+2
diff_ptr:
       equ  scroll_y+2
sprite_def_ptr:
       equ  diff_ptr+2
sprites_end_ptr:
       equ  sprite_def_ptr+2
pad_max:
       equ  sprites_end_ptr+2

***************************************************************
*
* Lower memory
*
       aorg >2000

***************************************************************
*
* Main program
*
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       li   r15,vdpwd                  ; Constant for writing to VDP
       bl   @graphics_mode
restart:
       bl   @init_level
loop:
       bl   @vsync
       bl   @set_vdp_regs
       bl   @draw_sprites
       mov  @scroll_x,r0
       andi r0,7
       jne  !
       bl   @upload_characters
       bl   @draw_column
!:
       bl   @move_sprites
       bl   @create_sprites
       bl   @scroll
       c    @scroll_x,@scroll_max
       jl   loop
       jmp  restart

scroll_max:
       data map_width*8+window_width

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,@vdp_status
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       rt
*// vsync

*********************************************************************
*
* Set VDP registers
*
set_vdp_regs:
       .proc
*      Calculate vertical page and offset
       clr  r1
       mov  @scroll_y,r2
       li   r3,screen_height
       div  r3,r1                      ; r1 quotient, r2 remainder
*      Horizontal scroll offset
       mov  @scroll_x,r0
       andi r0,>00ff
       ori  r0,>1b00
       bl   @vwtr
*      Vertical scroll offset
       mov  r2,r0
       ori  r0,>1c00
       bl   @vwtr
*      Horizontal page start
       mov  @scroll_x,r0
       andi r0,screen_width            ; Isolate bit value 256
       swpb r0                         ; Shift to bit 0
*      Vertical page start
       andi r1,1                       ; Bit 0 of quotient
       sla  r1,1                       ; Shift to bit 1
       soc  r1,r0                      ; Combine with horizontal bit
*      Set current name table
       ori  r0,>0200                   ; Name table
       bl   @vwtr
       .endproc
*// set_vdp_regs

*********************************************************************
*
* Draw sprites
*
draw_sprites:
       .proc
       li   r0,spratb
       bl   @vwad
       li   r4,sprites
       clr  r0
draw_sprites_1:
       c    r4,@sprites_end_ptr
       jeq  draw_sprites_4
       mov  @sprite_type(r4),r6
       jeq  draw_sprites_3
       ai   r6,sprite_type_n_hw_sprites
       mov  *r6+,r2                    ; Number of hardware sprites
draw_sprites_2:
       mov  @sprite_y(r4),r1
       ab   *r6+,r1
       movb r1,*r15
       mov  @sprite_x(r4),r1
       ab   *r6+,r1
       movb r1,*r15
       movb *r6+,*r15
       movb *r6+,*r15
       inc  r0
       dec  r2
       jne  draw_sprites_2
draw_sprites_3:
       ai   r4,sprite_size
       jmp  draw_sprites_1
draw_sprites_4:
       ori  r0,>3300
       bl   @vwtr
       .endproc
*// draw_sprites

*********************************************************************
*
* Upload characters
*
* diff_ptr points to the difference structure
*
upload_characters:
       .proc
       mov  @diff_ptr,r5
       ci   r5,diff_end
       jhe  upload_characters_2
       clr  r6
       movb *r5+,r6
       jeq  upload_characters_2
       swpb r6
upload_characters_1:
       clr  r0
       movb *r5+,r0
       swpb r0
       movb *r5+,r1
       swpb r1
       movb *r5+,r1
       swpb r1
       bl   @upload_character
       dec  r6
       jne  upload_characters_1
upload_characters_2:
       mov  r5,@diff_ptr
       .endproc
*// upload_characters

*********************************************************************
*
* Upload character
*
* r0: VDP index
* r1: Global index
*
upload_character:
       .proc
       mov  r0,r3
       mov  r1,r4
*      Tile attribute
       ai   r0,tilatb
       movb @TAT0(r1),r1
       bl   @vsbw
*      Pattern
       mov  r3,r0
       mov  r4,r1
       sla  r0,3
       ai   r0,ptrntb
       sla  r1,3
       ai   r1,P0_0
       li   r2,3
upload_character_1:
       bl   @vwad
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       ai   r0,ptrnt1-ptrnt0
       ai   r1,P1_0-P0_0-8
       dec  r2
       jne  upload_character_1
       .endproc
*// upload_character

*********************************************************************
*
* Draw column
*
draw_column:
       .proc
*      Set VDP address increment
       li   r0,>3020                   ; Set VDP address increment
       bl   @vwtr                      ; to 32
*      Calculate VDP address
       mov  @scroll_x,r0
       ai   r0,window_width+window_left ; Right side of window
       mov  r0,r1
       andi r0,screen_width            ; 0 or 256
       sla  r0,2                       ; Name table offset (0 or 1024)
       srl  r1,3                       ; Offset in characters
       andi r1,screen_width_chars-1
       a    r1,r0                      ; Add to VDP address
*      Vertical
       clr  r2                         ; For division
       mov  @scroll_y,r3               ; Scroll offset
       ai   r3,window_top
       li   r4,screen_height           ; Divided by screen height
       div  r4,r2                      ; r2 quotient, r3 remainder
       andi r2,1                       ; Bit 0 of quotient
       sla  r2,11                      ; Name table offset
       a    r2,r0                      ; Add to VDP address
       srl  r3,3                       ; Vertical offset in characters
       mov  r3,r4
       sla  r3,5                       ; Vertical address offset
       a    r3,r0                      ; Add to VDP address
       bl   @vwad                      ; Set VDP address
*      Map address
       mov  @scroll_x,r1
       srl  r1,3                       ; Offset in characters
       ci   r1,map_width-1
       jlt  draw_column_0
       li   r1,map_width-1
draw_column_0:
       ai   r1,level_1_map
*      Draw column
       li   r2,map_height
draw_column_1:
       movb *r1,*r15
       ai   r1,map_width
       inc  r4                         ; Increase vertical offset
       ci   r4,screen_height_chars
       jlt  draw_column_2
       andi r0,>c1f
       li   r5,>800
       xor  r5,r0
       bl   @vwad
       clr  r4
draw_column_2:
       dec  r2
       jne  draw_column_1
*      Reset VDP address increment
       li   r0,>3001                   ; Set VDP address increment
       bl   @vwtr                      ; to 1
       .endproc
*// draw_column

*********************************************************************
*
* Move sprites
*
move_sprites:
       .proc
       li   r4,sprites
move_sprites_1:
       c    r4,@sprites_end_ptr
       jhe  move_sprites_4
       mov  @sprite_type(r4),r6
       jeq  move_sprites_2
       a    @sprite_base_vx,@sprite_x(r4)
       c    @sprite_x(r4),@sprite_x_max
       jh   move_sprites_2
       a    @sprite_base_vy,@sprite_y(r4)
       c    @sprite_y(r4),@sprite_y_max
       jh  move_sprites_2
*      Handler
       mov  @sprite_type_handler(r6),r0
       jeq  move_sprites_3
       bl   *r0
       jmp  move_sprites_3
*      Remove
move_sprites_2:
       clr  @sprite_type(r4)           ; Remove sprite
       mov  @sprites_end_ptr,r5
       ai   r5,-sprite_size
       c    r4,r5
       jne  move_sprites_3
       mov  r5,@sprites_end_ptr
*      Next
move_sprites_3:
       ai   r4,sprite_size
       jmp  move_sprites_1
move_sprites_4:
       .endproc
sprite_base_vx:
       data ->0100
sprite_base_vy:
       data >0080
sprite_x_max:
       data >f000
sprite_y_max:
       data >f000
*// move_sprites

*********************************************************************
*
* Create sprites
*
create_sprites:
       .proc
       mov  @sprite_def_ptr,r6
create_sprites_1:
       mov  @sprite_def_x(r6),r0
       a    @sprite_def_delay(r6),r0
       c    @scroll_x,r0
       jl   create_sprites_2
       bl   @create_sprite
       ai   r6,sprite_def_size
       jmp create_sprites_1
create_sprites_2:
       mov  r6,@sprite_def_ptr
       .endproc
*// create_sprites

*********************************************************************
*
* Create sprite
*
* r6: sprite def
*
create_sprite:
       .proc
       bl   @allocate_sprite
       mov  r4,r4
       jeq  create_sprite_2
create_sprite_1:
       mov  @sprite_def_type(r6),r7
       mov  r7,@sprite_type(r4)
       mov  @sprite_def_delay(r6),r0
       li   r1,sprite_create_x
       s    r0,r1
       s    @sprite_type_cx(r7),r1
       swpb r1
       mov  r1,@sprite_x(r4)
       li   r1,window_top
       a    @sprite_def_y(r6),r1
       sra  r0,1
       a    r0,r1
       s    @sprite_type_cy(r7),r1
       swpb r1
       mov  r1,@sprite_y(r4)
       mov  @sprite_type_handler(r7),r0
       jeq  create_sprite_2
       seto @sprite_counter(r4)        ; Initial value
       bl   *r0
create_sprite_2:
       .endproc
*// create_sprite

*********************************************************************
*
* Allocate sprite
*
allocate_sprite:
       .proc
       li   r4,sprites
allocate_sprite_1:
       c    r4,@sprites_end_ptr
       jeq  allocate_sprite_2
       mov  @sprite_type(r4),r0
       jeq  allocate_sprite_2
       ai   r4,sprite_size
       jmp  allocate_sprite_1
allocate_sprite_2:
       ci   r4,sprites+(sprite_size*max_sprites)
       jl   allocate_sprite_3
       clr  r4
       jmp  allocate_sprite_4
allocate_sprite_3:
       mov  @sprites_end_ptr,r5
       c    r4,r5
       jne  allocate_sprite_4
       ai   r5,sprite_size
       mov  r5,@sprites_end_ptr
allocate_sprite_4:
       .endproc
*// allocate_sprite

*********************************************************************
*
* Allign sprites to the same screen position
*
* r4: sprite to align from
* r5: sprite to align
*
align_sprites:
       mov  @sprite_type(r4),r6
       mov  @sprite_type(r5),r7
       mov  @sprite_x(r4),r0
       srl  r0,8
       a    @sprite_type_cx(r6),r0
       s    @sprite_type_cx(r7),r0
       sla  r0,8
       mov  r0,@sprite_x(r5)
       mov  @sprite_y(r4),r0
       srl  r0,8
       a    @sprite_type_cy(r6),r0
       s    @sprite_type_cy(r7),r0
       sla  r0,8
       mov  r0,@sprite_y(r5)
       rt
*// allign_sprites

*********************************************************************
*
* Scroll
*
scroll:
       .proc
       mov  @scroll_x,r0
       inc  r0
       mov  r0,@scroll_x
       andi r0,1
       jne  scroll_1
       dec  @scroll_y
scroll_1:
       .endproc
*// scroll

*********************************************************************
*
* Set graphics mode
*
graphics_mode:
       .proc
       li   r1,vdp_registers
graphics_mode_1:
       mov  *r1+,r0
       jlt  graphics_mode_2
       bl   @vwtr                      ; Set register
       jmp  graphics_mode_1
*      Load color palettes
graphics_mode_2:
       li   r0,>2fc0                   ; Reg 47, DPM = 1, AUTO INC = 1, start PR0
       bl   @vwtr
*      Every two bytes written to the VDP now go to the palette registers
       li   r0,PAL0
       LI   r2,128                     ; Each of 64 12-bit palette entries requires 2 bytes
graphics_mode_3:
       movb *r0+,*r15
       dec  r2
       jne  graphics_mode_3
       .endproc
*      VDP registers
vdp_registers:
       byte >39,>1c                    ; Unlock F18A
       byte >39,>1c                    ; Unlock F18A
       byte >00,>00                    ; Graphics I mode
       byte >01,>e2                    ; 16K, display on, interrupt enabled
       byte >02,nametb/>400            ; Name table
       byte >03,tilatb/>40             ; Tile attribute table
       byte >04,ptrntb/>800            ; Pattern table
       byte >05,spratb/>80             ; Sprite attribute table
       byte >06,sprptb/>800            ; Sprite pattern table
       byte >07,backdrop_color         ; Backdrop color
       byte >31,>f3                    ; Reg 49: Enhanced color mode (ECM3 tiles and sprites, 30 rows, tl2)
       byte >1b,>00                    ; Reg 27: Horizontal scroll offset
       byte >1c,>00                    ; Reg 28: Vertical scroll offset
       byte >1d,>43                    ; Reg 29: Page size (1K between sprite patten tables, 2 x 2 scroll size)
;       byte >1d,>03                    ; Reg 29: Page size (2K between sprite patten tables, 2 x 2 scroll size)
       byte >0a,nam2tb/>400            ; Reg 10: Name table 2
       byte >0b,tilatb/>40             ; Reg 11: Tile attribute table 2
       byte >33,>00                    ; Reg 15: All sprites off
       data -1
*// graphics_mode

*********************************************************************
*
* Init level
*
init_level:
       .proc
       li   r0,>01a2                   ; Displaÿ off
       bl   @vwtr
       bl   @upload_sprite_patterns
;       bl   @gpu_copy
       bl   @clear_vdp_ram
       bl   @init_tl2
       bl   @vsync
       li   r0,>01e2                   ; Displaÿ on
       bl   @vwtr
       clr  @scroll_x
       li   r0,>800
       mov  r0,@scroll_y
       li   r0,level_1_000_add
       mov  r0,@diff_ptr
       li   r0,sprites
       mov  r0,@sprites_end_ptr
       li   r0,sprite_defs
       mov  r0,@sprite_def_ptr
       seto @map_bank_select
       .endproc
*// init_level

*********************************************************************
*
* Clear VDP RAM
*
clear_vdp_ram:
       .proc
       clr  r0                         ; Clear name table and pattern tables
       clr  r1
       li   r2,>3000
       bl   @vsmw
       li   r0,>3300                  ; Disable sprites
       bl   @vwtr
       .endproc
*// clear_vdp_ram

*********************************************************************
*
* Upload sprite patterns
*
upload_sprite_patterns:
       .proc
       li   r0,sprpt0
       li   r1,S0_0
       li   r2,32*32
       bl   @vmbw
       li   r0,sprpt1
       li   r1,S1_0
       li   r2,32*32
       bl   @vmbw
       li   r0,sprpt2
;       li   r0,0                       ; Plane 2 will be copied to >4000
       li   r1,S2_0
       li   r2,32*32
       bl   @vmbw
       .endproc
*// upload_sprite_patterns

*********************************************************************
*
* Init tile layer 2
*
init_tl2:
       .proc
       li   r0,nam2tb
       li   r1,MD0
       li   r2,960
       bl   @vmbw
       li   r0,ptrnt0+(tl2_first_char*8)
       li   r1,P0_250x
       li   r2,tl2_chars*8
       bl   @vmbw
       li   r0,tilatb+tl2_first_char
       li   r1,TAT250x
       li   r2,tl2_chars
       bl   @vmbw
       .endproc
*// init_tl2

***************************************************************
*
* GPU program to copy VDP RAM >0000->07ff to >4000->47ff
*
gpu_copy:
       .proc
*      Copy program to VDP RAM
       li   r0,gpu_run
       li   r1,gpu_program
       li   r2,gpu_program_end-gpu_program
       bl   @vmbw
*      Set the GPU PC which also triggers it
       li   r0,gpu_run/256+>3600
       bl   @vwtr
       li   r0,>3700
       bl   @vwtr
       .endproc
*      GPU code
gpu_program:
       clr  r0
       li   r1,>4000
       li   r2,>800
gpu_program_1:
       mov  *r0+,*r1+
       dect r2
       jne  gpu_program_1
       idle
gpu_program_end:
       equ  $
*// gpu_copy

***************************************************************
*
* Includes
*
       copy "vdp.a99"
       copy "sprite-handlers.a99"
       copy "tile-attrs.a99"

lower_memory_max:
       equ  $

***************************************************************
*
* Upper memory
*
       aorg >a000

       copy "diff1.a99"
diff_end:
       copy "tl2.a99"
       copy "chars1.a99"
       copy "sprite-patterns.a99"
       copy "sprite-types.a99"
       copy "sprite-defs.a99"
       copy "palettes.a99"
       copy "sprites.a99"

upper_memory_max:
       equ  $

***************************************************************

       end
