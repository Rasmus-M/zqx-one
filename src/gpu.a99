gpu_sprite_index:
       equ  0
gpu_sprite_x:
       equ  2
gpu_sprite_y:
       equ  4
gpu_sprite_z:
       equ  6
gpu_sprite_size:
       equ  8

***************************************************************
*
* Copy GPU program to VDP RAM
*
upload_gpu_program:
       .proc
*      Upload to tmp location
       li   r0,gputmp
       li   r1,gpu_program
       li   r2,gpu_program_end-gpu_program
*      Move to final location
       bl   @vmbw
       li   r0,gputmp/256+>3600
       bl   @vwtr
       li   r0,gputmp%256+>3700
       bl   @vwtr
       .endproc
*// upload_gpu_program

***************************************************************
*
* Run GPU program
*
gpu_run:
       .proc
*      Set the GPU PC which also triggers it
       li   r0,gpuprg/256+>3600
       bl   @vwtr
       li   r0,gpuprg%256+>3700
       bl   @vwtr
       .endproc
*// gpu_run

***************************************************************
*
* GPU program
*
gpu_program:
       li   r0,gputmp+(gpu_program_start-gpu_program)
       li   r1,gpuprg
       li   r2,gpu_program_end-gpu_program_start
gpu_program_copy:
       mov  *r0+,*r1+
       dect r2
       jne  gpu_program_copy
       idle
gpu_program_start:
       xorg gpuprg
       call @sort_sprites
       call @generate_sals
       call @split_screen
*      Return
       idle
**
*      Sort sprites front to back
*
sort_sprites:
       li   r0,>0500                   ; Blue border
       movb r0,@>6007
       li   r3,sprbuf
sort_sprites_1:
       mov  *r3+,r0                    ; Get sprite type index
       jlt  sort_sprites_3             ; -1 = End
       mov  *r3+,r1                    ; x
       s    *r3+,r1                    ; -y
       inct r3                         ; Skip z
       mov  r3,r4
sort_sprites_2:
       mov  *r4+,r0                    ; Get sprite type index
       jlt  sort_sprites_1             ; -1 = End
       mov  *r4+,r2                    ; x
       s    *r4+,r2                    ; -y
       inct r4                         ; Skip z
       c    r1,r2
       jlt  sort_sprites_2
*      Swap sprites
       mov  r3,r5
       ai   r5,-8
       mov  r4,r6
       ai   r6,-8
       mov  *r5,r0
       mov  *r6,*r5+
       mov  r0,*r6+
       mov  *r5,r0
       mov  *r6,*r5+
       mov  r0,*r6+
       mov  *r5,r0
       mov  *r6,*r5+
       mov  r0,*r6+
       mov  *r5,r0
       mov  *r6,*r5+
       mov  r0,*r6+
       jmp  sort_sprites_2
sort_sprites_3:
       ret
**
*      Generate sprite attribute lists
*
generate_sals:
       li   r0,>0600                   ; Yellow border
       movb r0,@>6007
       li   r3,spratb                  ; Top dest
       li   r4,sprat2                  ; Bottom dest
       clr  r5                         ; Number of top sprites
       clr  r6                         ; Number of bottom sprites
       li   r9,sprbuf
generate_sals_1:
       mov  *r9+,r0                    ; Get sprite type index
       jlt  generate_sals_6            ; -1 = End
       mov  *r9+,r10                   ; Get x0
       mov  *r9+,r11                   ; Get y0
       mov  *r9+,r12                   ; Get z0
       s    @scrlpv,r10                ; Adjust for scrolling
*      Isometric projection
       mov  r10,r13                    ; Save x0
       a    r11,r10                    ; x0 + y0
       s    r13,r11                    ; y0 - x0
       sra  r11,1                      ; (y0 - x0) / 2
       s    r12,r11                    ; (y0 - x0) / 2 - z0
*      Adjust for screen layout
       ai   r11,isometric_z0           ; Adjust zero height level
       ai   r10,isometric_x0           ; Adjust for screen layout
       ai   r11,isometric_y0           ; Adjust for screen layout
*      Check if whole sprite is out of screen
       c    r10,@hw_sprite_x_max
       jgt  generate_sals_1            ; Skip
       c    r11,@hw_sprite_y_max
       jgt  generate_sals_1            ; Skip
*      Locate sprite attributes
       sla  r0,1                       ; Index to word offset
       ai   r0,sprite_attrs_table      ; Index entry
       a    *r0,r0                     ; Add offset to sprite attributes
       mov  *r0+,r2                    ; Number of hardware sprites for this sprite
generate_sals_2:
*      Calculate position
       movb *r0+,r7                    ; Get dy
       sra  r7,8
       movb *r0+,r8                    ; Get dx
       sra  r8,8
       mov  *r0+,r1                    ; Get pattern and color
       a    r11,r7                     ; y0 + dy
*      Check position
       c    r7,@hw_sprite_y_min
       jlt  generate_sals_5            ; Out of screen top
       c    r7,@hw_sprite_y_max
       jgt  generate_sals_5            ; Out of screen bottom
       swpb r7
       a    r10,r8                     ; x0 + dy
       jlt  generate_sals_5            ; Out of screen left
       c    r8,@hw_sprite_x_max
       jgt  generate_sals_5            ; Out of screen right
       swpb r8
*      Check for inclusion in top SAL
       cb   r7,@hw_sprite_y_max+1
       jh   generate_sals_3            ; OK - top of screen
       cb   r7,@split_y
       jhe  generate_sals_4            ; Not OK - bottom
generate_sals_3:
       ci   r5,32
       jhe  generate_sals_4            ; Not OK - no more sprites
*      OK for inclusion in top SAL
       movb r7,*r3+
       movb r8,*r3+
       mov  r1,*r3+
       inc  r5
*      Check for inclusion in bottom SAL
generate_sals_4:
       cb   r7,@hw_sprite_y_max+1
       jhe  generate_sals_5            ; Not OK - top of screen
       cb   r7,@split_y_top
       jl   generate_sals_5            ; Not OK - top of screen
       ci   r6,32
       jhe  generate_sals_5            ; Not OK - no more sprites
*      OK for inclusion in bottom SAL
       movb r7,*r4+
       movb r8,*r4+
       mov  r1,*r4+
       inc  r6
*      Next hardware sprite
generate_sals_5:
       dec  r2
       jne  generate_sals_2
*      Next sprite
       jmp  generate_sals_1
*      Record number of sprites in each SAL
generate_sals_6:
       swpb r5
       movb r5,@top_sprites
       swpb r6
       movb r6,@bottom_sprites
       ret
**
*      Handle split screen
*
split_screen:
       clr  r0
       movb r0,@>6007                  ; Black border
*      Set sprite attribute table 1
       li   r0,(spratb/>80)*256        ; Value for VR5 (table 1)
       movb r0,@>6005                  ; Set VR5
       movb @top_sprites,@>6033        ; Set max sprites (VR51)
*      Set hsync trigger
       movb @>6032,r0                  ; Get contens of VR50
       ori  r0,>4000                   ; Set hsync bit
       movb r0,@>6032                  ; Set VR50
*      Return
split_screen_1:
       idle
*      Hsync handler
       cb   @>7000,@split_y            ; Check scanline number
       jne  split_screen_1             ; Wait if not reached
*      Set sprite attribute table 2
       li   r0,(sprat2/>80)*256        ; Value for VR5 (table 2)
       movb r0,@>6005                  ; Set VR5
       movb @bottom_sprites,@>6033     ; Set max sprites (VR51)
*      Clear hsync trigger
       movb @>6032,r0                  ; Get contens of VR50
       andi r0,>bfff                   ; Clear hsync bit
       movb r0,@>6032                  ; Set VR50
*      Return
       ret

split_y:
       byte >90
split_y_top:
       byte >80
hw_sprite_x_max:
       data 240-1
hw_sprite_y_min:
       data -16
hw_sprite_y_max:
       data 240-1
top_sprites:
       byte 0
bottom_sprites:
       byte 0
*      Sprite attributes
       copy "sprite-attrs.a99"
       aorg
gpu_program_end:
       equ  $
*// gpu_program
